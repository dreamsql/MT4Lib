//+------------------------------------------------------------------+
//|																	 |
//|								Copyright 2012-2017, M.Hatoum.		 |
//|																	 |
//+------------------------------------------------------------------+
//|                   DO NOT EDIT THIS FILE!!!                       |
//+------------------------------------------------------------------+
// NoStyler
#pragma once
#include <windows.h>
#using <mscorlib.dll>
#include <atlstr.h>
#using <System.Drawing.dll>

using namespace System;
using namespace System::Runtime::InteropServices;
using namespace System::Drawing;

#define TO_COLOR(cf) Color::FromArgb(0xFF, (int)(cf & 0x000000FF), (int)((cf & 0x0000FF00) >> 8), (int)((cf & 0x00FF0000) >> 16))
#define TO_COLORREF(argb) (int)((argb & 0x00FF0000) >> 16) | (int)(argb & 0x0000FF00) | (int)((argb & 0x000000FF) << 16)

namespace MetaQuotes {
#include "MT4ManagerAPI.h"
}

namespace Helpers {

	class Helper
	{
	public:
		static char* GetBody(MetaQuotes::MailBox  data) {
			return data.body;

		}
		static void SetBody(MetaQuotes::MailBox*  data, char* body) {
			data->body = body;

		}

		static wchar_t* GetTopicBody(MetaQuotes::NewsTopicNew*  data) {
			return data->body;

		}

		static char* GetNewsTopicBody(MetaQuotes::NewsTopic  data) {
			return data.body;

		}

		static void SetNewsBody(MetaQuotes::NewsTopic*  data, char* body) {
			data->body = body;

		}

		static MetaQuotes::PluginCfg GetParameters(MetaQuotes::ConPluginParam*  data, int index) {
			return data->params[index];

		}

		static void FillParameters(MetaQuotes::ConPluginParam* configuration, MetaQuotes::PluginCfg parameter, int index)
		{
			configuration->params[index] = parameter;
		}

	};

}


namespace Manager {
	
//+------------------------------------------------------------------+
//|                   Server Configurations                          |
//+------------------------------------------------------------------+
//| Configuration types                                              |
//+------------------------------------------------------------------+

		public enum class ConfigurationTypes
		{
			CONFIG_ALL = 0,                             // all configurations
			CONFIG_COMMON,                            // common configuration
			CONFIG_ACCESS,                            // IP access list configuration
			CONFIG_SERVERS,                           // data servers
			CONFIG_TIME,                              // working time configuration
			CONFIG_HOLIDAYS,                          // holidays configuration
			CONFIG_SYMBOLS,                           // symbols configuration
			CONFIG_SYMB_GROUPS,                       // securities configuration
			CONFIG_GROUPS,                            // groups configuration
			CONFIG_MANAGERS,                          // manager's rights configuration
			CONFIG_DATAFEEDS,                         // data feeds configuration
			CONFIG_BACKUP,                            // backups configuration
			CONFIG_LIVEUPDATE,                        // LiveUpdate configuration
			CONFIG_SYNC,                              // synchronization configuration
			CONFIG_PLUGINS,                           // plugins configuration
			CONFIG_GATEWAY_ACCOUNTS,                  // gateway accounts
			CONFIG_GATEWAY_MARKUPS,                   // gateway markups
			CONFIG_GATEWAY_RULES,                     // gateway rules
			CONFIG_END = 255                            // last (unused)
		};

//+------------------------------------------------------------------+
//| Configuration structures                                         |
//+------------------------------------------------------------------+
//| Common configuration                                             |
//+------------------------------------------------------------------+
		[Serializable]
		public value class ConCommon {
		public:

			ConCommon(MetaQuotes::ConCommon &tr)
			{
				owner = Marshal::PtrToStringAnsi(IntPtr(tr.owner));
				name = Marshal::PtrToStringAnsi(IntPtr(tr.name)); 
				address = tr.address;
				port = tr.port;
				timeout = tr.timeout;
				typeofdemo = tr.typeofdemo;
				timeofdemo = tr.timeofdemo;
				daylightcorrection = tr.daylightcorrection;
				internal = Marshal::PtrToStringAnsi(IntPtr(tr.internal));
				timezone_real = tr.timezone_real;
				timezone = tr.timezone;
				timesync = Marshal::PtrToStringAnsi(IntPtr(tr.timesync));

				minclient = tr.minclient;
				minapi = tr.minapi;
				feeder_timeout = tr.feeder_timeout;
				keepemails = tr.keepemails;
				endhour = tr.endhour;
				endminute = tr.endminute;

				optimization_time = tr.optimization_time;
				optimization_lasttime = tr.optimization_lasttime;
				optimization_counter = tr.optimization_counter;

				antiflood = tr.antiflood;
				floodcontrol = tr.floodcontrol;

				liveupdate_mode = tr.liveupdate_mode;

				lastorder = tr.lastorder;
				lastlogin = tr.lastlogin;
				lostlogin = tr.lostlogin;

				rollovers_mode = tr.rollovers_mode;

				path_database = Marshal::PtrToStringAnsi(IntPtr(tr.path_database));
				path_history = Marshal::PtrToStringAnsi(IntPtr(tr.path_history));
				path_log = Marshal::PtrToStringAnsi(IntPtr(tr.path_log));

				overnight_last_day = tr.overnight_last_day;
				overnight_last_time = tr.overnight_last_time;
				overnight_prev_time = tr.overnight_prev_time;

				overmonth_last_month = tr.overmonth_last_month;
				
				adapters = Marshal::PtrToStringAnsi(IntPtr(tr.adapters));
				bind_adresses = gcnew System::Collections::Generic::List<unsigned int>();
				for (int i = 0; i < 8; i++)
				 bind_adresses->Add(tr.bind_adresses[i]);
				server_version = tr.server_version;
				server_build = tr.server_build;
				web_adresses = gcnew System::Collections::Generic::List<unsigned int>();
				for (int i = 0; i < 8; i++)
					web_adresses->Add(tr.web_adresses[i]);
				statement_mode = tr.statement_mode;
				monthly_state_mode = tr.monthly_state_mode;
				keepticks = tr.keepticks;
				statement_weekend = tr.statement_weekend;
				last_activate = tr.last_activate;
				stop_last = tr.stop_last;
				stop_delay = tr.stop_delay;
				stop_reason = tr.stop_reason;
				account_url = Marshal::PtrToStringAnsi(IntPtr(tr.account_url));
			}
			ConCommon(MetaQuotes::ConCommon *tr)
			{
				owner = Marshal::PtrToStringAnsi(IntPtr(tr->owner));
				name = Marshal::PtrToStringAnsi(IntPtr(tr->name));
				address = tr->address;
				port = tr->port;
				timeout = tr->timeout;
				typeofdemo = tr->typeofdemo;

				timeofdemo = tr->timeofdemo;
				daylightcorrection = tr->daylightcorrection;
				internal = Marshal::PtrToStringAnsi(IntPtr(tr->internal));
				minclient = tr->minclient;
				timezone_real = tr->timezone_real;
				timezone = tr->timezone;
				internal = Marshal::PtrToStringAnsi(IntPtr(tr->timesync));
				minapi = tr->minapi;
				feeder_timeout = tr->feeder_timeout;
				keepemails = tr->keepemails;

				endhour = tr->endhour;
				endminute = tr->endminute;
				optimization_time = tr->optimization_time;
				optimization_lasttime = tr->optimization_lasttime;
				optimization_counter = tr->optimization_counter;

				antiflood = tr->antiflood;
				floodcontrol = tr->floodcontrol;
				liveupdate_mode = tr->liveupdate_mode;
				lastorder = tr->lastorder;
				lastlogin = tr->lastlogin;
				lostlogin = tr->lostlogin;
				rollovers_mode = tr->rollovers_mode;
				path_database = Marshal::PtrToStringAnsi(IntPtr(tr->path_database));
				path_history = Marshal::PtrToStringAnsi(IntPtr(tr->path_history));
				path_log = Marshal::PtrToStringAnsi(IntPtr(tr->path_log));
				overnight_last_day = tr->overnight_last_day;
				overnight_last_time = tr->overnight_last_time;
				overnight_prev_time = tr->overnight_prev_time;
				overmonth_last_month = tr->overmonth_last_month;
				adapters = Marshal::PtrToStringAnsi(IntPtr(tr->adapters));
				bind_adresses = gcnew System::Collections::Generic::List<unsigned int>();
				for (int i = 0; i < 8; i++)
					bind_adresses->Add(tr->bind_adresses[i]);
				
				server_version = tr->server_version;
				server_build = tr->server_build;
				web_adresses = gcnew System::Collections::Generic::List<unsigned int>();
				for (int i = 0; i < 8; i++)
					web_adresses->Add(tr->web_adresses[i]);
				statement_mode = tr->statement_mode;
				monthly_state_mode = tr->monthly_state_mode;
				keepticks = tr->keepticks;
				statement_weekend = tr->statement_weekend;
				last_activate = tr->last_activate;
				stop_last = tr->stop_last;
				stop_delay = tr->stop_delay;
				stop_reason = tr->stop_reason;
				account_url = Marshal::PtrToStringAnsi(IntPtr(tr->account_url));
			}
			void ToMT4(MetaQuotes::ConCommon *con)
			{
				IntPtr temp_field;
				char* temp;
				temp_field = Marshal::StringToHGlobalAnsi(owner);
				temp = (char*)temp_field.ToPointer();
				if (temp != NULL)
				strcpy(con->owner, (char *)(void *)temp_field);
				Marshal::FreeHGlobal(temp_field);

				temp_field = Marshal::StringToHGlobalAnsi(name);
				temp = (char*)temp_field.ToPointer();
				if (temp != NULL)
				strcpy(con->name, (char *)(void *)temp_field);
				Marshal::FreeHGlobal(temp_field);
				con->address = address;
				con->port = port;
				con->timeout = timeout;
				con->typeofdemo = typeofdemo;
				con->timeofdemo = timeofdemo;
				con->daylightcorrection = daylightcorrection;
				temp_field = Marshal::StringToHGlobalAnsi(internal);
				temp = (char*)temp_field.ToPointer();
				if (temp != NULL)
				strcpy(con->internal, (char *)(void *)temp_field);
				Marshal::FreeHGlobal(temp_field);
			
				con->timezone_real = timezone_real;
				con->timezone = timezone;
				temp_field = Marshal::StringToHGlobalAnsi(timesync);
				temp = (char*)temp_field.ToPointer();
				if (temp != NULL)
				strcpy(con->timesync, (char *)(void *)temp_field);
				Marshal::FreeHGlobal(temp_field);

				con->minclient = minclient;
				con->minapi = minapi;
				con->feeder_timeout = feeder_timeout;
				con->keepemails = keepemails;
				con->endhour = endhour;
				con->endminute = endminute;

				con->optimization_time = optimization_time;
				con->optimization_lasttime = optimization_lasttime;
				con->optimization_counter = optimization_counter;

				con->antiflood = antiflood;
				con->floodcontrol = floodcontrol;

				con->liveupdate_mode = liveupdate_mode;

				con->lastorder = lastorder;
				con->lastlogin = lastlogin;
				con->lostlogin = lostlogin;

				con->rollovers_mode = rollovers_mode;
				temp_field = Marshal::StringToHGlobalAnsi(path_database);
				temp = (char*)temp_field.ToPointer();
				if (temp != NULL)
				strcpy(con->path_database, (char *)(void *)temp_field);
				Marshal::FreeHGlobal(temp_field);

				temp_field = Marshal::StringToHGlobalAnsi(path_history);
				temp = (char*)temp_field.ToPointer();
				if (temp != NULL)
				strcpy(con->path_history, (char *)(void *)temp_field);
				Marshal::FreeHGlobal(temp_field);
				
				temp_field = Marshal::StringToHGlobalAnsi(path_log);
				temp = (char*)temp_field.ToPointer();
				if (temp != NULL)
				strcpy(con->path_log, (char *)(void *)temp_field);
				Marshal::FreeHGlobal(temp_field);

				con->overnight_last_day = overnight_last_day;
				con->overnight_last_time = overnight_last_time;
				con->overnight_prev_time = overnight_prev_time;

				con->overmonth_last_month = overmonth_last_month;
				temp_field = Marshal::StringToHGlobalAnsi(adapters);
				temp = (char*)temp_field.ToPointer();
				if (temp != NULL)
				strcpy(con->adapters, (char *)(void *)temp_field);
				Marshal::FreeHGlobal(temp_field);
				
				for (int i = 0; i < 8; i++)
					con->bind_adresses[i]=bind_adresses[i];
				con->server_version = server_version;
				con->server_build = server_build;
				
				for (int i = 0; i < 8; i++)
					con->web_adresses[i] = web_adresses[i];
				con->statement_mode = statement_mode;
				con->monthly_state_mode = monthly_state_mode;
				con->keepticks = keepticks;
				con->statement_weekend = statement_weekend;
				con->last_activate = last_activate;
				con->stop_last = stop_last;
				con->stop_delay = stop_delay;
				con->stop_reason = stop_reason;
				temp_field = Marshal::StringToHGlobalAnsi(account_url);
				temp = (char*)temp_field.ToPointer();
				if (temp != NULL)
				strcpy(con->account_url, (char *)(void *)temp_field);
				Marshal::FreeHGlobal(temp_field);
				
			}


			String           ^owner;				 // servers owner (include version & build)
			String           ^name;                  // server name
			ULONG             address;               // IP address assigned to the server
			int               port;                  // port
			DWORD             timeout;               // sockets timeout
			int               typeofdemo;            // demo-accounts type (DEMO_DISABLED, DEMO_PROLONG, DEMO_FIXED)
			int               timeofdemo;            // demo-account living time
			int               daylightcorrection;    // allow daylight correction
			String           ^internal;				 // reserved
			int               timezone_real;         // time zone with day light mode
			int               timezone;              // time zone 0-GMT;-1=GMT-1;1=GMT+1;
			String           ^timesync;              // time synchronization server address
													 //---
			int               minclient;             // minimal authorized client version
			int               minapi;                // minimal authorized client version
			DWORD             feeder_timeout;        // data feed switch timeout
			int               keepemails;            // internal mail keep period
			int               endhour, endminute;    // end of day time-hour & minute
													 //---
			int               optimization_time;     // optimization start time (minutes)
			int               optimization_lasttime; // optimization last time
			int               optimization_counter;  // internal variable
			
													 //---
			int               antiflood;             // enable antiflood control
			int               floodcontrol;          // max. antiflood connections
													 //---
			int               liveupdate_mode;       // LiveUpdate mode (LIVE_UPDATE_NO,LIVE_UPDATE_ALL,LIVE_UPDATE_NO_SERVER)
													 //---
			int               lastorder;             // last order's ticket     (read only)
			int               lastlogin;             // last account's number   (read only)
			int               lostlogin;             // lost commission's login (read only)
													 //---
			int               rollovers_mode;        // rollover mode (ROLLOVER_NORMAL,ROLLOVER_REOPEN_BY_CLOSE_PRICE,ROLLOVER_REOPEN_BY_BID)
													 //---
			String           ^path_database;		 // path to databases
			String           ^path_history;			 // path to history bases
			String           ^path_log;				 // path to log
													 //--- overnigths
			__time32_t        overnight_last_day;    // day of last overnight
			__time32_t        overnight_last_time;   // time of last overnight
			__time32_t        overnight_prev_time;   // time of âðåìÿ next to last overnight
													 //--- month reports
			__time32_t        overmonth_last_month;  // month of last report
													 //--- performance base
			String           ^adapters;				 // network adapters list (read-only)
			List<unsigned int> ^bind_adresses;		 // array of avaible IP addresses
			short             server_version;        // server version
			short             server_build;          // server build
			List<unsigned int> ^web_adresses;          // web services access list (comma separated IP addresses)
			int               statement_mode;        // statement generation time (STATEMENT_END_DAY,STATEMENT_START_DAY)
			int               monthly_state_mode;    // monthly statement generation day (MONTHLY_STATEMENT_END_MONTH,MONTHLY_STATEMENT_START_MONTH)
			int               keepticks;             // ticks keep period
			int               statement_weekend;     // generate statements at weekends
			__time32_t        last_activate;         // last activation datetime
			__time32_t        stop_last;             // last stop datetime
			int               stop_delay;            // last stop delay
			int               stop_reason;           // last stop reason
			String           ^account_url;			 // account allocation URL
			
		};
		
//--- demo-accounts type
public enum class DemoTypes { DEMO_DISABLED, DEMO_PROLONG, DEMO_FIXED };
//--- rollover mode
public enum class RollOverModes { ROLLOVER_NORMAL, ROLLOVER_REOPEN_BY_CLOSE_PRICE, ROLLOVER_REOPEN_BY_BID };
//--- LiveUpdate mode
public enum class LiveUpdateModes { LIVE_UPDATE_NO = 0, LIVE_UPDATE_RELEASE = 1, LIVE_UPDATE_NO_SERVER = 2, LIVE_UPDATE_BETA = 3 };
//--- monthly statement mode
public enum class MonthlyStatementModes { MONTHLY_STATEMENT_END_MONTH, MONTHLY_STATEMENT_START_MONTH };
//--- server stop reason
public enum class ServerStopReason { STOP_REASON_NONE, STOP_REASON_RESTART, STOP_REASON_SHUTDOWN, STOP_REASON_LIVEUPDATE };

//+------------------------------------------------------------------+
//| Access configuration                                             |
//+------------------------------------------------------------------+
[Serializable]
public value class ConAccess
{
public:
	int               action;            // type of action (FW_BLOCK,FW_PERMIT)
	unsigned long     from, to;          // from, to addresses
	String           ^comment;           // comment
	

	ConAccess(MetaQuotes::ConAccess &tr)
	{
		comment = Marshal::PtrToStringAnsi(IntPtr(tr.comment));
		action = tr.action;
		from = tr.from;
		to = tr.to;	
		
	}

	ConAccess(MetaQuotes::ConAccess *tr)
	{
		comment = Marshal::PtrToStringAnsi(IntPtr(tr->comment));
		action = tr->action;
		from = tr->from;
		to = tr->to;

	}


	void ToMT4(MetaQuotes::ConAccess* Con) {
		Con->action = action;
		Con->from = from;
		Con->to = to;
		IntPtr temp_comment;
		char* temp;
		temp_comment = Marshal::StringToHGlobalAnsi(comment);
		temp = (char*)temp_comment.ToPointer();
		if (temp != NULL)
		strcpy(Con->comment, (char *)(void *)temp_comment);
		Marshal::FreeHGlobal(temp_comment);
	}
};

//--- access action
public enum class AccessAction { FW_BLOCK, FW_PERMIT };

//+------------------------------------------------------------------+
//| Data Servers configuration                                       |
//+------------------------------------------------------------------+
[Serializable]
public value class ConDataServer
{
public:
	String           ^server;             // server address (server:ip)
	ULONG             ip;                 // server IP
	String           ^description;        // server description
	int               isproxy;                // can server be proxy?
	int               priority;               // priority: 0-7 base, 255-idle
	UINT              loading;                // server loading (UINT_MAX-server does not inform its loading)
	ULONG             ip_internal;            // internal IP address
	
	ConDataServer(MetaQuotes::ConDataServer &tr)
	{
		server = Marshal::PtrToStringAnsi(IntPtr(tr.server));
		ip = tr.ip;
		description = Marshal::PtrToStringAnsi(IntPtr(tr.description));
		isproxy = tr.isproxy;
		priority = tr.priority;
		loading = tr.loading;
		ip_internal = tr.ip_internal;

	}

	ConDataServer(MetaQuotes::ConDataServer *tr)
	{
		server = Marshal::PtrToStringAnsi(IntPtr(tr->server));
		ip = tr->ip;
		description = Marshal::PtrToStringAnsi(IntPtr(tr->description));
		isproxy = tr->isproxy;
		priority = tr->priority;
		loading = tr->loading;
		ip_internal = tr->ip_internal;

	}

	void ToMT4(MetaQuotes::ConDataServer* Con) {
		IntPtr temp_server;
		char * temp;
		temp_server = Marshal::StringToHGlobalAnsi(server);
		temp = (char*)temp_server.ToPointer();
		if (temp != NULL)
		strcpy(Con->server, (char *)(void *)temp_server);
		Con->ip = ip;
		Marshal::FreeHGlobal(temp_server);
		IntPtr temp_description;
		temp_description = Marshal::StringToHGlobalAnsi(description);
		temp = (char*)temp_description.ToPointer();
		if (temp != NULL)
		strcpy(Con->description, (char *)(void *)temp_description);
		Marshal::FreeHGlobal(temp_description);
		Con->isproxy = isproxy;
		Con->priority = priority;
		Con->loading = loading;
		Con->ip_internal = ip_internal;
	}

};

//+------------------------------------------------------------------+
//| Time configuration                                               |
//+------------------------------------------------------------------+
[Serializable]
public value class ConTime
{
public:
	Collections::Generic::IList<Collections::Generic::IList<int>^>   ^days;	// server's accessebility (7 days-24 hours, 0-denied, 1-allowed)
	int               dayscontrol;           // internal variable
	ConTime(MetaQuotes::ConTime &tr)
	{
		days = gcnew System::Collections::Generic::List<System::Collections::Generic::IList<int>^>();
		for (int day = 0; day < 7; day++) {
			System::Collections::Generic::IList<int>^ dayValues = gcnew System::Collections::Generic::List<int>();
			for (int hour = 0; hour < 24; hour++)
				dayValues->Add(tr.days[day][hour]);
			days->Add(dayValues);
		}
	}

	ConTime(MetaQuotes::ConTime* tr)
	{
		days = gcnew System::Collections::Generic::List<System::Collections::Generic::IList<int>^>();
		for (int day = 0; day < 7; day++) {
			System::Collections::Generic::IList<int>^ dayValues = gcnew System::Collections::Generic::List<int>();
			for (int hour = 0; hour < 24; hour++)
				dayValues->Add(tr->days[day][hour]);
			days->Add(dayValues);
		}
	}

	void ToMT4(MetaQuotes::ConTime* Con) {

		if (days->Count != 7)
			throw gcnew ArgumentException("Invalid number of days");
		for (int day = 0; day < 7; day++) {
			if (days[day]->Count != 24)
				throw gcnew ArgumentException("Invalid number of hours");
			for (int hour = 0; hour < 24; hour++)
			{
				System::Collections::Generic::IList<int>^ values = days[day];
				Con->days[day][hour] = values[hour];
			}
		}

		Con->dayscontrol = dayscontrol;
	}

};

//+------------------------------------------------------------------+
//| Backup configuration                                             |
//+------------------------------------------------------------------+
[Serializable]
public value class ConBackup
{
public:
	ConBackup(MetaQuotes::ConBackup &con) {
			
		//---
		fullbackup_path = Marshal::PtrToStringAnsi(IntPtr(con.fullbackup_path));       // path to backup
		fullbackup_period = con.fullbackup_period;      // full backup's period-BACKUP_1HOUR, BACKUP_4HOURS, BACKUP_1DAY
		fullbackup_store = con.fullbackup_store;       // full backup's store time-BU_STORE_1MONTH, BU_STORE_3MONTHS, BU_STORE_6MONTHS,BU_STORE_1YEAR
		fullbackup_lasttime = con.fullbackup_lasttime;    // full backup's last execution time
		fullbackup_shift = con.fullbackup_shift;       // full backup timeshift (minutes)
													   //---
		external_path = Marshal::PtrToStringAnsi(IntPtr(con.external_path));         // path to external processing directory
																					 //---
		archive_period = con.archive_period;         // period of archive backup-ARC_BACKUP_5MIN, ARC_BACKUP_15MIN, ARC_BACKUP_30MIN, ARC_BACKUP_1HOUR
		archive_store = con.archive_store;          // archive backup's store time-ARC_STORE_1WEEK, ARC_STORE_2WEEKS, ARC_STORE_1MONTH, ARC_STORE_3MONTH, ARC_STORE_6MONTH
		archive_lasttime = con.archive_lasttime;       // archive backup's last execution time
													   //---
		export_securities = Marshal::PtrToStringAnsi(IntPtr(con.export_securities));     // comma separated list of exported securities
		export_path = Marshal::PtrToStringAnsi(IntPtr(con.export_path));           // path to export script
		export_period = con.export_period;          // export period-enumeration EXPORT_1MIN, EXPORT_5MIN, EXPORT_15MIN, EXPORT_30MIN,EXPORT_1HOUR
		export_lasttime = con.export_lasttime;        // export's last execution time
													  //--- watch dog
		watch_role = con.watch_role;             // server role { WATCH_STAND_ALONE, WATCH_MASTER, WATCH_SLAVE }
		watch_password = Marshal::PtrToStringAnsi(IntPtr(con.watch_password));        // slave server password
		watch_opposite = Marshal::PtrToStringAnsi(IntPtr(con.watch_opposite));        // opposite server IP address and port
		watch_ip = con.watch_ip;               // opposite server IP
											   //--- 
		archive_shift = con.archive_shift;          // shift of archive backup time (in minutes)
													//---
		watch_state = con.watch_state;            // watch dog state
		watch_failover = con.watch_failover;         // watch dog failover mode
		watch_timeout = con.watch_timeout;          // watch dog timeout
		watch_login = con.watch_login;            // watch dog login
		watch_timestamp = con.watch_timestamp;        // watch dog timestamp
	}
	ConBackup(MetaQuotes::ConBackup* con) {

		//---
		fullbackup_path = Marshal::PtrToStringAnsi(IntPtr(con->fullbackup_path));       // path to backup
		fullbackup_period = con->fullbackup_period;      // full backup's period-BACKUP_1HOUR, BACKUP_4HOURS, BACKUP_1DAY
		fullbackup_store = con->fullbackup_store;       // full backup's store time-BU_STORE_1MONTH, BU_STORE_3MONTHS, BU_STORE_6MONTHS,BU_STORE_1YEAR
		fullbackup_lasttime = con->fullbackup_lasttime;    // full backup's last execution time
		fullbackup_shift = con->fullbackup_shift;       // full backup timeshift (minutes)
														//---
		external_path = Marshal::PtrToStringAnsi(IntPtr(con->external_path));         // path to external processing directory
																					  //---
		archive_period = con->archive_period;         // period of archive backup-ARC_BACKUP_5MIN, ARC_BACKUP_15MIN, ARC_BACKUP_30MIN, ARC_BACKUP_1HOUR
		archive_store = con->archive_store;          // archive backup's store time-ARC_STORE_1WEEK, ARC_STORE_2WEEKS, ARC_STORE_1MONTH, ARC_STORE_3MONTH, ARC_STORE_6MONTH
		archive_lasttime = con->archive_lasttime;       // archive backup's last execution time
														//---
		export_securities = Marshal::PtrToStringAnsi(IntPtr(con->export_securities));     // comma separated list of exported securities
		export_path = Marshal::PtrToStringAnsi(IntPtr(con->export_path));           // path to export script
		export_period = con->export_period;          // export period-enumeration EXPORT_1MIN, EXPORT_5MIN, EXPORT_15MIN, EXPORT_30MIN,EXPORT_1HOUR
		export_lasttime = con->export_lasttime;        // export's last execution time
													   //--- watch dog
		watch_role = con->watch_role;             // server role { WATCH_STAND_ALONE, WATCH_MASTER, WATCH_SLAVE }
		watch_password = Marshal::PtrToStringAnsi(IntPtr(con->watch_password));        // slave server password
		watch_opposite = Marshal::PtrToStringAnsi(IntPtr(con->watch_opposite));        // opposite server IP address and port
		watch_ip = con->watch_ip;               // opposite server IP
												//--- 
		archive_shift = con->archive_shift;          // shift of archive backup time (in minutes)
													 //---
		watch_state = con->watch_state;            // watch dog state
		watch_failover = con->watch_failover;         // watch dog failover mode
		watch_timeout = con->watch_timeout;          // watch dog timeout
		watch_login = con->watch_login;            // watch dog login
		watch_timestamp = con->watch_timestamp;        // watch dog timestamp
	}

	void ToMT4(MetaQuotes::ConBackup* Con) {
		IntPtr temp_fullbackup_path;
		char* temp;
		temp_fullbackup_path = Marshal::StringToHGlobalAnsi(fullbackup_path);
		strcpy(Con->fullbackup_path, (char *)(void *)temp_fullbackup_path);
		temp = (char*)temp_fullbackup_path.ToPointer();
		if (temp != NULL)
		Marshal::FreeHGlobal(temp_fullbackup_path);
		Con->fullbackup_period = fullbackup_period;
		Con->fullbackup_store = fullbackup_store;
		Con->fullbackup_lasttime = fullbackup_lasttime;
		Con->fullbackup_shift = fullbackup_shift;
		IntPtr temp_external_path;
		temp_external_path = Marshal::StringToHGlobalAnsi(external_path);
		temp = (char*)temp_external_path.ToPointer();
		if (temp != NULL)
		strcpy(Con->external_path, (char *)(void *)temp_external_path);
		Marshal::FreeHGlobal(temp_external_path);
		Con->archive_period = archive_period;
		Con->archive_store = archive_store;
		Con->archive_lasttime = archive_lasttime;
		IntPtr temp_export_securities;
		temp_export_securities = Marshal::StringToHGlobalAnsi(export_securities);
		temp = (char*)temp_export_securities.ToPointer();
		if (temp != NULL)
		strcpy(Con->export_securities, (char *)(void *)temp_export_securities);
		Marshal::FreeHGlobal(temp_export_securities);
		IntPtr temp_export_path;
		temp_export_path = Marshal::StringToHGlobalAnsi(export_path);
		temp = (char*)temp_export_path.ToPointer();
		if (temp != NULL)
		strcpy(Con->export_path, (char *)(void *)temp_export_path);
		Marshal::FreeHGlobal(temp_export_path);
		Con->export_period = export_period;
		Con->export_lasttime = export_lasttime;
		Con->watch_role = watch_role;
		IntPtr temp_watch_password;
		temp_watch_password = Marshal::StringToHGlobalAnsi(watch_password);
		temp = (char*)temp_watch_password.ToPointer();
		if (temp != NULL)
		strcpy(Con->watch_password, (char *)(void *)temp_watch_password);
		Marshal::FreeHGlobal(temp_watch_password);
		IntPtr temp_watch_opposite;
		temp_watch_opposite = Marshal::StringToHGlobalAnsi(watch_opposite);
		temp = (char*)temp_watch_opposite.ToPointer();
		if (temp != NULL)
		strcpy(Con->watch_opposite, (char *)(void *)temp_watch_opposite);
		Marshal::FreeHGlobal(temp_watch_opposite);
		Con->watch_ip = watch_ip;
		Con->archive_shift = archive_shift;
		Con->watch_state = watch_state;
		Con->watch_failover = watch_failover;
		Con->watch_timeout = watch_timeout;
		Con->watch_login = watch_login;
		Con->watch_timestamp = watch_timestamp;
	}


	//---
	String            ^fullbackup_path;       // path to backup
	int               fullbackup_period;      // full backup's period-BACKUP_1HOUR, BACKUP_4HOURS, BACKUP_1DAY
	int               fullbackup_store;       // full backup's store time-BU_STORE_1MONTH, BU_STORE_3MONTHS, BU_STORE_6MONTHS,BU_STORE_1YEAR
	__time32_t        fullbackup_lasttime;    // full backup's last execution time
	short             fullbackup_shift;       // full backup timeshift (minutes)
											  //---
	String            ^external_path;         // path to external processing directory
											  //---
	int               archive_period;         // period of archive backup-ARC_BACKUP_5MIN, ARC_BACKUP_15MIN, ARC_BACKUP_30MIN, ARC_BACKUP_1HOUR
	int               archive_store;          // archive backup's store time-ARC_STORE_1WEEK, ARC_STORE_2WEEKS, ARC_STORE_1MONTH, ARC_STORE_3MONTH, ARC_STORE_6MONTH
	__time32_t        archive_lasttime;       // archive backup's last execution time
											  //---
	String            ^export_securities;     // comma separated list of exported securities
	String            ^export_path;           // path to export script
	int               export_period;          // export period-enumeration EXPORT_1MIN, EXPORT_5MIN, EXPORT_15MIN, EXPORT_30MIN,EXPORT_1HOUR
	__time32_t        export_lasttime;        // export's last execution time
											  //--- watch dog
	int               watch_role;             // server role { WATCH_STAND_ALONE, WATCH_MASTER, WATCH_SLAVE }
	String            ^watch_password;        // slave server password
	String            ^watch_opposite;        // opposite server IP address and port
	int               watch_ip;               // opposite server IP
											  //--- 
	char              archive_shift;          // shift of archive backup time (in minutes)
											  //---
	char              watch_state;            // watch dog state
	char              watch_failover;         // watch dog failover mode
	unsigned char     watch_timeout;          // watch dog timeout
	int               watch_login;            // watch dog login
	__time32_t        watch_timestamp;        // watch dog timestamp
};


//--- server role
public enum class ServerRole { WATCH_STAND_ALONE, WATCH_MASTER, WATCH_SLAVE };
//--- full backup execution periods: 1 hour, 4 hours, 1 day
public enum class FullBackUpHours { BACKUP_1HOUR, BACKUP_4HOURS, BACKUP_1DAY };
//--- full backup store period: 1 month, 3 months, 6 months, 1 year
public enum class FullBackUpMonths { BU_STORE_1MONTH, BU_STORE_3MONTHS, BU_STORE_6MONTHS, BU_STORE_1YEAR };
//--- arc. backup execution periods: 5 min, 15 min, 30 min, 1 hour
public enum class ArchiveBackUpminutes { ARC_BACKUP_DISABLED, ARC_BACKUP_5MIN, ARC_BACKUP_15MIN, ARC_BACKUP_30MIN, ARC_BACKUP_1HOUR };
//--- arc. backup store period: 1 day, 3 days, 1 week, 2 weeks, 1 month,3 months, 6 months,1 year
public enum class ArchiveBackUpDays { ARC_STORE_1DAY, ARC_STORE_3DAYS, ARC_STORE_1WEEK, ARC_STORE_2WEEKS, ARC_STORE_1MONTH, ARC_STORE_3MONTH, ARC_STORE_6MONTH };
//--- export execution period: 1 min, 5 min, 15 min, 30 min, 1 hour
public enum class ExportExecution { EXPORT_1MIN, EXPORT_5MIN, EXPORT_15MIN, EXPORT_30MIN, EXPORT_1HOUR };
//--- watchdog state
public enum class WatchdogState { WS_DISCONNECTED, WS_SYNCHRONIZING, WS_SYNCHRONIZED };
//--- watchdog failover mode
public enum class WatchdogFailoverMode { FAILOVER_OFF, FAILOVER_MOST, FAILOVER_FULL };

//+------------------------------------------------------------------+
//| Datafeed configuration                                           |
//+------------------------------------------------------------------+
[Serializable]
public value class ConFeeder
{
public:
	ConFeeder(MetaQuotes::ConFeeder &con) {
	
		name = Marshal::PtrToStringAnsi(IntPtr(con.name));              // name
		file = Marshal::PtrToStringAnsi(IntPtr(con.file));             // datafeed filename
		server = Marshal::PtrToStringAnsi(IntPtr(con.server));            // server address
		login = Marshal::PtrToStringAnsi(IntPtr(con.login));             // datafeed login
		pass = Marshal::PtrToStringAnsi(IntPtr(con.pass));              // datafeed password
		keywords = Marshal::PtrToStringAnsi(IntPtr(con.keywords));         // keywords (news filtration)
		enable = con.enable;                // enable feeder
		mode = con.mode;                  // datafeed mode-enumeration FEED_QUOTES, FEED_NEWS, FEED_QUOTESNEWS
		timeout = con.timeout;               // max. freeze time (default ~120 sec.)
		timeout_reconnect = con.timeout_reconnect;     // reconnect timeout before attemps_sleep connect attempts (default ~ 5  sec)
		timeout_sleep = con.timeout_sleep;         // reconnect timeout after attemps_sleep connect attempts  (default ~ 60 sec)
		attemps_sleep = con.attemps_sleep;         // reconnect count (see timeout_reconnect & timeout_sleep)
		news_langid = con.news_langid;           // news language id
	
	}

	ConFeeder(MetaQuotes::ConFeeder* con) {

		name = Marshal::PtrToStringAnsi(IntPtr(con->name));              // name
		file = Marshal::PtrToStringAnsi(IntPtr(con->file));             // datafeed filename
		server = Marshal::PtrToStringAnsi(IntPtr(con->server));            // server address
		login = Marshal::PtrToStringAnsi(IntPtr(con->login));             // datafeed login
		pass = Marshal::PtrToStringAnsi(IntPtr(con->pass));              // datafeed password
		keywords = Marshal::PtrToStringAnsi(IntPtr(con->keywords));         // keywords (news filtration)
		enable = con->enable;                // enable feeder
		mode = con->mode;                  // datafeed mode-enumeration FEED_QUOTES, FEED_NEWS, FEED_QUOTESNEWS
		timeout = con->timeout;               // max. freeze time (default ~120 sec.)
		timeout_reconnect = con->timeout_reconnect;     // reconnect timeout before attemps_sleep connect attempts (default ~ 5  sec)
		timeout_sleep = con->timeout_sleep;         // reconnect timeout after attemps_sleep connect attempts  (default ~ 60 sec)
		attemps_sleep = con->attemps_sleep;         // reconnect count (see timeout_reconnect & timeout_sleep)
		news_langid = con->news_langid;           // news language id

	}
	
	void ToMT4(MetaQuotes::ConFeeder* Con) {
		IntPtr temp_name;
		char* temp;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Con->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		IntPtr temp_file;
		temp_file = Marshal::StringToHGlobalAnsi(file);
		temp = (char*)temp_file.ToPointer();
		if (temp != NULL)
		strcpy(Con->file, (char *)(void *)temp_file);
		Marshal::FreeHGlobal(temp_file);
		IntPtr temp_server;
		temp_server = Marshal::StringToHGlobalAnsi(server);
		temp = (char*)temp_server.ToPointer();
		if (temp != NULL)
		strcpy(Con->server, (char *)(void *)temp_server);
		Marshal::FreeHGlobal(temp_server);
		IntPtr temp_login;
		temp_login = Marshal::StringToHGlobalAnsi(login);
		temp = (char*)temp_login.ToPointer();
		if (temp != NULL)
		strcpy(Con->login, (char *)(void *)temp_login);
		Marshal::FreeHGlobal(temp_login);
		IntPtr temp_pass;
		temp_pass = Marshal::StringToHGlobalAnsi(pass);
		temp = (char*)temp_pass.ToPointer();
		if (temp != NULL)
		strcpy(Con->pass, (char *)(void *)temp_pass);
		Marshal::FreeHGlobal(temp_pass);
		IntPtr temp_keywords;
		temp_keywords = Marshal::StringToHGlobalAnsi(keywords);
		temp = (char*)temp_keywords.ToPointer();
		if (temp != NULL)
		strcpy(Con->keywords, (char *)(void *)temp_keywords);
		Marshal::FreeHGlobal(temp_keywords);
		Con->enable = enable;
		Con->mode = mode;
		Con->timeout = timeout;
		Con->timeout_reconnect = timeout_reconnect;
		Con->timeout_sleep = timeout_sleep;
		Con->attemps_sleep = attemps_sleep;
		Con->news_langid = news_langid;
	}
	
	String            ^name;              // name
	String            ^file;             // datafeed filename
	String            ^server;            // server address
	String            ^login;             // datafeed login
	String            ^pass;              // datafeed password
	String            ^keywords;         // keywords (news filtration)
	int               enable;                // enable feeder
	int               mode;                  // datafeed mode-enumeration FEED_QUOTES, FEED_NEWS, FEED_QUOTESNEWS
	int               timeout;               // max. freeze time (default ~120 sec.)
	int               timeout_reconnect;     // reconnect timeout before attemps_sleep connect attempts (default ~ 5  sec)
	int               timeout_sleep;         // reconnect timeout after attemps_sleep connect attempts  (default ~ 60 sec)
	int               attemps_sleep;         // reconnect count (see timeout_reconnect & timeout_sleep)
	int               news_langid;           // news language id
	
};

//--- datafeed modes-receive quotes, receive news, receive quotes and news
public enum class DataFeedModes { FEED_QUOTES = 0, FEED_NEWS = 1, FEED_QUOTESNEWS = 2 };

//+------------------------------------------------------------------+
//| Security group configuration for client group                    |
//+------------------------------------------------------------------+
//---
public value class ConGroupSec
{
public:

	int               show, trade;            // enable show and trade for this group of securites
	int               execution;             // dealing mode-EXECUTION_MANUAL,EXECUTION_AUTO,EXECUTION_ACTIVITY
											 //--- comission settings
	double            comm_base;             // standart commission
	int               comm_type;             // commission type-COMM_TYPE_MONEY,COMM_TYPE_PIPS,COMM_TYPE_PERCENT
	int               comm_lots;             // commission lots mode-COMMISSION_PER_LOT,COMMISSION_PER_DEAL
	double            comm_agent;            // agent commission
	int               comm_agent_type;       // agent commission mode-COMM_TYPE_MONEY, COMM_TYPE_PIPS
											 //---
	int               spread_diff;           // spread difference in compare with default security spread
											 //---
	int               lot_min, lot_max;       // allowed minimal and maximal lot values
	int               lot_step;              // allowed step value (10 lot-1000, 1 lot-100, 0.1 lot-10)
	int               ie_deviation;          // maximum price deviation in Instant Execution mode
	int               confirmation;          // use confirmation in Request mode
	int               trade_rights;          // clients trade rights-bit mask see TRADE_DENY_NONE,TRADE_DENY_CLOSEBY,TRADE_DENY_MUCLOSEBY
	int               ie_quick_mode;         // do not resend request to the dealer when client uses deviation
	int               autocloseout_mode;     // auto close-out method { CLOSE_OUT_NONE, CLOSE_OUT_HIHI, CLOSE_OUT_LOLO, CLOSE_OUT_HILO, CLOSE_OUT_LOHI, CLOSE_OUT_LOHI, CLOSE_OUT_FIFO, CLOSE_OUT_LIFO, CLOSE_OUT_INTRDAY_FIFO }
	double            comm_tax;              // commission taxes
	int               comm_agent_lots;       // agent commission per lot/per deal { COMMISSION_PER_LOT,COMMISSION_PER_DEAL }
	int               freemargin_mode;       // "soft" margin check
	
public:
	ConGroupSec(MetaQuotes::ConGroupSec& sec)
	{

		show = sec.show;
		trade = sec.trade;            // enable show and trade for this group of securites
		execution = sec.execution;             // dealing mode-EXECUTION_MANUAL,EXECUTION_AUTO,EXECUTION_ACTIVITY

		comm_base = sec.comm_base;             // standart commission
		comm_type = sec.comm_type;             // commission type-COMM_TYPE_MONEY,COMM_TYPE_PIPS,COMM_TYPE_PERCENT
		comm_lots = sec.comm_lots;             // commission lots mode-COMMISSION_PER_LOT,COMMISSION_PER_DEAL
		comm_agent = sec.comm_agent;            // agent commission
		comm_agent_type = sec.comm_agent_type;       // agent commission mode-COMM_TYPE_MONEY, COMM_TYPE_PIPS

		spread_diff = sec.spread_diff;           // spread difference in compare with default security spread

		lot_min = sec.lot_min;
		lot_max = sec.lot_max;       // allowed minimal and maximal lot values
		lot_step = sec.lot_step;              // allowed step value (10 lot-1000, 1 lot-100, 0.1 lot-10)
		ie_deviation = sec.ie_deviation;          // maximum price deviation in Instant Execution mode
		confirmation = sec.confirmation;          // use confirmation in Request mode
		trade_rights = sec.trade_rights;          // clients trade rights-bit mask see TRADE_DENY_NONE,TRADE_DENY_CLOSEBY,TRADE_DENY_MUCLOSEBY
		ie_quick_mode = sec.ie_quick_mode;         // do not resend request to the dealer when client uses deviation
		autocloseout_mode = sec.autocloseout_mode;     // auto close-out method { CLOSE_OUT_NONE, CLOSE_OUT_HIHI, CLOSE_OUT_LOLO, CLOSE_OUT_HILO, CLOSE_OUT_LOHI, CLOSE_OUT_LOHI, CLOSE_OUT_FIFO, CLOSE_OUT_LIFO, CLOSE_OUT_INTRDAY_FIFO }
		comm_tax = sec.comm_tax;              // commission taxes
		comm_agent_lots = sec.comm_agent_lots;       // agent commission per lot/per deal { COMMISSION_PER_LOT,COMMISSION_PER_DEAL }
		freemargin_mode = sec.freemargin_mode;       // "soft" margin check

	}


	ConGroupSec(MetaQuotes::ConGroupSec* sec)
	{

		show = sec->show;
		trade = sec->trade;            // enable show and trade for this group of securites
		execution = sec->execution;             // dealing mode-EXECUTION_MANUAL,EXECUTION_AUTO,EXECUTION_ACTIVITY

		comm_base = sec->comm_base;             // standart commission
		comm_type = sec->comm_type;             // commission type-COMM_TYPE_MONEY,COMM_TYPE_PIPS,COMM_TYPE_PERCENT
		comm_lots = sec->comm_lots;             // commission lots mode-COMMISSION_PER_LOT,COMMISSION_PER_DEAL
		comm_agent = sec->comm_agent;            // agent commission
		comm_agent_type = sec->comm_agent_type;       // agent commission mode-COMM_TYPE_MONEY, COMM_TYPE_PIPS

		spread_diff = sec->spread_diff;           // spread difference in compare with default security spread

		lot_min = sec->lot_min;
		lot_max = sec->lot_max;       // allowed minimal and maximal lot values
		lot_step = sec->lot_step;              // allowed step value (10 lot-1000, 1 lot-100, 0.1 lot-10)
		ie_deviation = sec->ie_deviation;          // maximum price deviation in Instant Execution mode
		confirmation = sec->confirmation;          // use confirmation in Request mode
		trade_rights = sec->trade_rights;          // clients trade rights-bit mask see TRADE_DENY_NONE,TRADE_DENY_CLOSEBY,TRADE_DENY_MUCLOSEBY
		ie_quick_mode = sec->ie_quick_mode;         // do not resend request to the dealer when client uses deviation
		autocloseout_mode = sec->autocloseout_mode;     // auto close-out method { CLOSE_OUT_NONE, CLOSE_OUT_HIHI, CLOSE_OUT_LOLO, CLOSE_OUT_HILO, CLOSE_OUT_LOHI, CLOSE_OUT_LOHI, CLOSE_OUT_FIFO, CLOSE_OUT_LIFO, CLOSE_OUT_INTRDAY_FIFO }
		comm_tax = sec->comm_tax;              // commission taxes
		comm_agent_lots = sec->comm_agent_lots;       // agent commission per lot/per deal { COMMISSION_PER_LOT,COMMISSION_PER_DEAL }
		freemargin_mode = sec->freemargin_mode;       // "soft" margin check

	}

	void ToMT4(MetaQuotes::ConGroupSec* Con) {
		Con->show = show;
		Con->trade = trade;
		Con->execution = execution;
		Con->comm_base = comm_base;
		Con->comm_type = comm_type;
		Con->comm_lots = comm_lots;
		Con->comm_agent = comm_agent;
		Con->comm_agent_type = comm_agent_type;
		Con->spread_diff = spread_diff;
		Con->lot_min = lot_min;
		Con->lot_max = lot_max;
		Con->lot_step = lot_step;
		Con->ie_deviation = ie_deviation;
		Con->confirmation = confirmation;
		Con->trade_rights = trade_rights;
		Con->ie_quick_mode = ie_quick_mode;
		Con->autocloseout_mode = autocloseout_mode;
		Con->comm_tax = comm_tax;
		Con->comm_agent_lots = comm_agent_lots;
		Con->freemargin_mode = freemargin_mode;
	}


};

//+------------------------------------------------------------------+
//| Special securities configurations for client group               |
//+------------------------------------------------------------------+
[Serializable]
public value class  ConGroupMargin
{
public:
	String            ^symbol;            // security
	double            swap_long, swap_short;  // swap size for long and short positions
	double            margin_divider;        // margin divider

	ConGroupMargin(MetaQuotes::ConGroupMargin& sec)
	{
		symbol = Marshal::PtrToStringAnsi(IntPtr(sec.symbol));
		swap_long = sec.swap_long;
		swap_short = sec.swap_short;
		margin_divider = sec.margin_divider;
	}

	ConGroupMargin(MetaQuotes::ConGroupMargin* sec)
	{
		symbol = Marshal::PtrToStringAnsi(IntPtr(sec->symbol));
		swap_long = sec->swap_long;
		swap_short = sec->swap_short;
		margin_divider = sec->margin_divider;
	}

	void  ToMT4(MetaQuotes::ConGroupMargin* Con) {
		IntPtr temp_symbol;
		char *temp;
		
		temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
		temp = (char*)temp_symbol.ToPointer();
		if (temp != NULL)
		strcpy(Con->symbol, (char *)(void *)temp_symbol);
		Marshal::FreeHGlobal(temp_symbol);
		Con->swap_long = swap_long;
		Con->swap_short = swap_short;
		Con->margin_divider = margin_divider;
	}

};
//--- dealing mode
public enum class DealingModes { EXECUTION_MANUAL, EXECUTION_AUTO, EXECUTION_ACTIVITY };
//--- commission type
public enum class CommissionTypes { COMM_TYPE_MONEY, COMM_TYPE_PIPS, COMM_TYPE_PERCENT };
//--- comission lots mode
public enum class ComissionLotsModes { COMMISSION_PER_LOT, COMMISSION_PER_DEAL };
//--- clients trade rights
public enum class ClientsTradeRights { TRADE_DENY_NONE = 0, TRADE_DENY_CLOSEBY = 1, TRADE_DENY_MUCLOSEBY = 2 };
//--- auto close-out method
public enum class AutoCloseOutMethods { CLOSE_OUT_NONE, CLOSE_OUT_HIHI, CLOSE_OUT_LOLO, CLOSE_OUT_HILO, CLOSE_OUT_LOHI, CLOSE_OUT_FIFO, CLOSE_OUT_LIFO, CLOSE_OUT_INTRDAY_FIFO };


//+------------------------------------------------------------------+
//| Client group configuration                                       |
//+------------------------------------------------------------------+

[Serializable]
public ref class ConGroup
{
public:
	ConGroup(MetaQuotes::ConGroup& grp)
	{
		group = Marshal::PtrToStringAnsi(IntPtr(grp.group));                   // group name
		enable = grp.enable;                      // enable group
		timeout = grp.timeout;                     // trade confirmation timeout (seconds)
		otp_mode = grp.otp_mode;						// enable advanced security
												   //--- statements
		company = Marshal::PtrToStringAnsi(IntPtr(grp.company));                // company name
		signature = Marshal::PtrToStringAnsi(IntPtr(grp.signature));              // statements signature
		support_page = Marshal::PtrToStringAnsi(IntPtr(grp.support_page));           // company support page
		smtp_server = Marshal::PtrToStringAnsi(IntPtr(grp.smtp_server));             // statements SMTP server
		smtp_login = Marshal::PtrToStringAnsi(IntPtr(grp.smtp_login));              // statements SMTP login
		smtp_password = Marshal::PtrToStringAnsi(IntPtr(grp.smtp_password));           // statements SMTP password
		support_email = Marshal::PtrToStringAnsi(IntPtr(grp.support_email));           // support email
		templates = Marshal::PtrToStringAnsi(IntPtr(grp.templates));               // path to directory with custom templates
		copies = grp.copies;                      // copy statements on support email
		reports = grp.reports;                     // enable statements
												   //--- default settings
		default_leverage = grp.default_leverage;            // default leverage (user don't specify leverage himself)
		default_deposit = grp.default_deposit;             // default deposit  (user don't specify balance  himself)
														   //--- securities
		maxsecurities = grp.maxsecurities;               // maximum simultaneous securities


		secgroups = gcnew List<ConGroupSec>();           // security group settings

		for (int i = 0; i<MAX_SEC_GROUPS; i++) {

			ConGroupSec sec = ConGroupSec(grp.secgroups[i]);
			secgroups->Add(sec);

		}

		secmargins = gcnew List<ConGroupMargin>();// special securities settings

		for (int i = 0; i<MAX_SEC_GROPS_MARGIN; i++) {

			ConGroupMargin sec = ConGroupMargin(grp.secmargins[i]);
			secmargins->Add(sec);

		}

		secmargins_total = grp.secmargins_total;            // count of special securities settings
															//--- margin & erest
		currency = Marshal::PtrToStringAnsi(IntPtr(grp.currency));                // deposit currency
		credit = grp.credit;                      // virtual credit
		margin_call = grp.margin_call;                 // margin call level (percents)
		margin_mode = grp.margin_mode;                 // margin mode-MARGIN_DONT_USE,MARGIN_USE_ALL,MARGIN_USE_PROFIT,MARGIN_USE_LOSS
		margin_stopout = grp.margin_stopout;              // stop out level
		interestrate = grp.interestrate;                // annual erest rate (percents)
		use_swap = grp.use_swap;                    // use rollovers & erestrate
													//--- rights
		news = grp.news;                        // news mode
		rights = grp.rights;                      // rights bit mask-ALLOW_FLAG_EMAIL
		check_ie_prices = grp.check_ie_prices;             // check IE prices on requests
		maxpositions = grp.maxpositions;                // maximum orders and open positions
		close_reopen = grp.close_reopen;                // partial close mode (if !=0 original position will be fully closed and remain position will be fully reopened)
		hedge_prohibited = grp.hedge_prohibited;            // hedge prohibition flag
		close_fifo = grp.close_fifo;                  // fifo rule 
		hedge_largeleg = grp.hedge_largeleg;              // use large leg margin for hedged positions


		securities_hash = Marshal::PtrToStringAnsi(IntPtr(grp.currency));         // ernal data
																		//---
		margin_type = grp.margin_type;                 // margin controlling type { MARGIN_TYPE_PERCENT,  MARGIN_TYPE_CURRENCY }
													   //--- archives
		archive_period = grp.archive_period;              // inactivity period after which account moves to archive base (in days)
		archive_max_balance = grp.archive_max_balance;         // maxumum balance of accounts to move in archive base
															   //---
		stopout_skip_hedged = grp.stopout_skip_hedged;         // skip fully hedged accounts when checking for stopout
		archive_pending_period = grp.archive_pending_period;      // pendings clean period
																  //--- allowed news languages
	
		news_languages_total = grp.news_languages_total;        // news languages total
		news_languages = gcnew System::Collections::Generic::List<unsigned int>();
		for (int i = 0; i < (int)grp.news_languages_total; i++)
			news_languages->Add(grp.news_languages[i]);

	}

	ConGroup(MetaQuotes::ConGroup* grp)
	{
		group = Marshal::PtrToStringAnsi(IntPtr(grp->group));                   // group name
		enable = grp->enable;                      // enable group
		timeout = grp->timeout;                     // trade confirmation timeout (seconds)
		otp_mode = grp->otp_mode;						// enable advanced security
														//--- statements
		company = Marshal::PtrToStringAnsi(IntPtr(grp->company));                // company name
		signature = Marshal::PtrToStringAnsi(IntPtr(grp->signature));              // statements signature
		support_page = Marshal::PtrToStringAnsi(IntPtr(grp->support_page));           // company support page
		smtp_server = Marshal::PtrToStringAnsi(IntPtr(grp->smtp_server));             // statements SMTP server
		smtp_login = Marshal::PtrToStringAnsi(IntPtr(grp->smtp_login));              // statements SMTP login
		smtp_password = Marshal::PtrToStringAnsi(IntPtr(grp->smtp_password));           // statements SMTP password
		support_email = Marshal::PtrToStringAnsi(IntPtr(grp->support_email));           // support email
		templates = Marshal::PtrToStringAnsi(IntPtr(grp->templates));               // path to directory with custom templates
		copies = grp->copies;                      // copy statements on support email
		reports = grp->reports;                     // enable statements
													//--- default settings
		default_leverage = grp->default_leverage;            // default leverage (user don't specify leverage himself)
		default_deposit = grp->default_deposit;             // default deposit  (user don't specify balance  himself)
															//--- securities
		maxsecurities = grp->maxsecurities;               // maximum simultaneous securities


		secgroups = gcnew List<ConGroupSec>();           // security group settings

		for (int i = 0; i<MAX_SEC_GROUPS; i++) {

			ConGroupSec sec = ConGroupSec(grp->secgroups[i]);
			secgroups->Add(sec);

		}

		secmargins = gcnew List<ConGroupMargin>();// special securities settings

		for (int i = 0; i<MAX_SEC_GROPS_MARGIN; i++) {

			ConGroupMargin sec = ConGroupMargin(grp->secmargins[i]);
			secmargins->Add(sec);

		}
	
		secmargins_total = grp->secmargins_total;            // count of special securities settings
															 //--- margin & erest
		currency = Marshal::PtrToStringAnsi(IntPtr(grp->currency));                // deposit currency
		credit = grp->credit;                      // virtual credit
		margin_call = grp->margin_call;                 // margin call level (percents)
		margin_mode = grp->margin_mode;                 // margin mode-MARGIN_DONT_USE,MARGIN_USE_ALL,MARGIN_USE_PROFIT,MARGIN_USE_LOSS
		margin_stopout = grp->margin_stopout;              // stop out level
		interestrate = grp->interestrate;                // annual erest rate (percents)
		use_swap = grp->use_swap;                    // use rollovers & erestrate
													 //--- rights
		news = grp->news;                        // news mode
		rights = grp->rights;                      // rights bit mask-ALLOW_FLAG_EMAIL
		check_ie_prices = grp->check_ie_prices;             // check IE prices on requests
		maxpositions = grp->maxpositions;                // maximum orders and open positions
		close_reopen = grp->close_reopen;                // partial close mode (if !=0 original position will be fully closed and remain position will be fully reopened)
		hedge_prohibited = grp->hedge_prohibited;            // hedge prohibition flag
		close_fifo = grp->close_fifo;                  // fifo rule 
		hedge_largeleg = grp->hedge_largeleg;              // use large leg margin for hedged positions


		securities_hash = Marshal::PtrToStringAnsi(IntPtr(grp->currency));         // ernal data
																				   //---
		margin_type = grp->margin_type;                 // margin controlling type { MARGIN_TYPE_PERCENT,  MARGIN_TYPE_CURRENCY }
														//--- archives
		archive_period = grp->archive_period;              // inactivity period after which account moves to archive base (in days)
		archive_max_balance = grp->archive_max_balance;         // maxumum balance of accounts to move in archive base
																//---
		stopout_skip_hedged = grp->stopout_skip_hedged;         // skip fully hedged accounts when checking for stopout
		archive_pending_period = grp->archive_pending_period;      // pendings clean period
																   //--- allowed news languages

		news_languages_total = grp->news_languages_total;        // news languages total
		news_languages = gcnew System::Collections::Generic::List<unsigned int>();
		for (int i = 0; i < (int)grp->news_languages_total; i++)
			news_languages->Add(grp->news_languages[i]);
	}


	void ToMT4(MetaQuotes::ConGroup* Con) {
		IntPtr temp_group;
		char* temp;
		temp_group = Marshal::StringToHGlobalAnsi(group);
		temp = (char*)temp_group.ToPointer();
		if (temp != NULL)
		strcpy(Con->group, (char *)(void *)temp_group);
		Marshal::FreeHGlobal(temp_group);
		Con->enable = enable;
		Con->timeout = timeout;
		Con->otp_mode = otp_mode;
		IntPtr temp_company;
		temp_company = Marshal::StringToHGlobalAnsi(company);
		temp = (char*)temp_company.ToPointer();
		if (temp != NULL)
		strcpy(Con->company, (char *)(void *)temp_company);
		Marshal::FreeHGlobal(temp_company);
		IntPtr temp_signature;
		temp_signature = Marshal::StringToHGlobalAnsi(signature);
		temp = (char*)temp_signature.ToPointer();
		if (temp != NULL)
		strcpy(Con->signature, (char *)(void *)temp_signature);
		Marshal::FreeHGlobal(temp_signature);
		IntPtr temp_support_page;
		temp_support_page = Marshal::StringToHGlobalAnsi(support_page);
		temp = (char*)temp_support_page.ToPointer();
		if (temp != NULL)
		strcpy(Con->support_page, (char *)(void *)temp_support_page);
		Marshal::FreeHGlobal(temp_support_page);
		IntPtr temp_smtp_server;
		temp_smtp_server = Marshal::StringToHGlobalAnsi(smtp_server);
		temp = (char*)temp_smtp_server.ToPointer();
		if (temp != NULL)
		strcpy(Con->smtp_server, (char *)(void *)temp_smtp_server);
		Marshal::FreeHGlobal(temp_smtp_server);
		IntPtr temp_smtp_login;
		temp_smtp_login = Marshal::StringToHGlobalAnsi(smtp_login);
		temp = (char*)temp_smtp_login.ToPointer();
		if (temp != NULL)
		strcpy(Con->smtp_login, (char *)(void *)temp_smtp_login);
		Marshal::FreeHGlobal(temp_smtp_login);
		IntPtr temp_smtp_password;
		temp_smtp_password = Marshal::StringToHGlobalAnsi(smtp_password);
		temp = (char*)temp_smtp_password.ToPointer();
		if (temp != NULL)
		strcpy(Con->smtp_password, (char *)(void *)temp_smtp_password);
		Marshal::FreeHGlobal(temp_smtp_password);
		IntPtr temp_support_email;
		temp_support_email = Marshal::StringToHGlobalAnsi(support_email);
		temp = (char*)temp_support_email.ToPointer();
		if (temp != NULL)
		strcpy(Con->support_email, (char *)(void *)temp_support_email);
		Marshal::FreeHGlobal(temp_support_email);
		IntPtr temp_templates;
		temp_templates = Marshal::StringToHGlobalAnsi(templates);
		temp = (char*)temp_templates.ToPointer();
		if (temp != NULL)
		strcpy(Con->templates, (char *)(void *)temp_templates);
		Marshal::FreeHGlobal(temp_templates);
		Con->copies = copies;
		Con->reports = reports;
		Con->default_leverage = default_leverage;
		Con->default_deposit = default_deposit;
		Con->maxsecurities = maxsecurities;
		for (int i = 0; i < secmargins->Count; i++)
			secmargins[i].ToMT4(&Con->secmargins[i]);
			 

		for (int i = 0; i < secgroups->Count; i++)
			secgroups[i].ToMT4(&Con->secgroups[i]);


		Con->secmargins_total = secmargins_total;
		IntPtr temp_currency;
		temp_currency = Marshal::StringToHGlobalAnsi(currency);
		temp = (char*)temp_currency.ToPointer();
		if (temp != NULL)
		strcpy(Con->currency, (char *)(void *)temp_currency);
		Marshal::FreeHGlobal(temp_currency);
		Con->credit = credit;
		Con->margin_call = margin_call;
		Con->margin_mode = margin_mode;
		Con->margin_stopout = margin_stopout;
		Con->interestrate = interestrate;
		Con->use_swap = use_swap;
		Con->news = news;
		Con->rights = rights;
		Con->check_ie_prices = check_ie_prices;
		Con->maxpositions = maxpositions;
		Con->close_reopen = close_reopen;
		Con->hedge_prohibited = hedge_prohibited;
		Con->close_fifo = close_fifo;
		Con->hedge_largeleg = hedge_largeleg;
		IntPtr temp_securities_hash;
		temp_securities_hash = Marshal::StringToHGlobalAnsi(securities_hash);
		temp = (char*)temp_securities_hash.ToPointer();
		if (temp != NULL)
		strcpy(Con->securities_hash, (char *)(void *)temp_securities_hash);
		Marshal::FreeHGlobal(temp_securities_hash);
		Con->margin_type = margin_type;
		Con->archive_period = archive_period;
		Con->archive_max_balance = archive_max_balance;
		Con->stopout_skip_hedged = stopout_skip_hedged;
		Con->archive_pending_period = archive_pending_period;

		for (int i = 0; i < news_languages->Count; i++)
			news_languages[i]=Con->news_languages[i];

		Con->news_languages_total = news_languages_total;
		
	}


	//--- common settings
	String^           group;                   // group name
	int               enable;                      // enable group
	int               timeout;                     // trade confirmation timeout (seconds)
	int               otp_mode;                    // one-time password mode
	//--- statements
	String^              company;                // company name
	String^              signature;              // statements signature
	String^              support_page;           // company support page
	String^              smtp_server;             // statements SMTP server
	String^              smtp_login;              // statements SMTP login
	String^              smtp_password;           // statements SMTP password
	String^              support_email;           // support email
	String^              templates;               // path to directory with custom templates
	int               copies;                      // copy statements on support email
	int               reports;                     // enable statements
    //--- default settings
	int               default_leverage;            // default leverage (user don't specify leverage himself)
	double            default_deposit;             // default deposit  (user don't specify balance  himself)
	//--- securities
	int               maxsecurities;               // maximum simultaneous securities
	List<ConGroupSec>^       secgroups;   // security group settings
	List<ConGroupMargin>^    secmargins; // special securities settings
	int               secmargins_total;            // count of special securities settings
	//--- margin & interest
	String^           currency;                // deposit currency
	double            credit;                      // virtual credit
	int               margin_call;                 // margin call level (percents)
	int               margin_mode;                 // margin mode-MARGIN_DONT_USE,MARGIN_USE_ALL,MARGIN_USE_PROFIT,MARGIN_USE_LOSS
	int               margin_stopout;              // stop out level
	double            interestrate;                // annual interest rate (percents)
	int               use_swap;                    // use rollovers & interestrate
	//--- rights
	int               news;                        // news mode
	int               rights;                      // rights bit mask-ALLOW_FLAG_EMAIL
	int               check_ie_prices;             // check IE prices on requests
	int               maxpositions;                // maximum orders and open positions
	int               close_reopen;                // partial close mode (if !=0 original position will be fully closed and remain position will be fully reopened)
	int               hedge_prohibited;            // hedge prohibition flag
	int               close_fifo;                  // fifo rule 
	int               hedge_largeleg;              // use large leg margin for hedged positions

	String^           securities_hash;         // internal data
	//---
	int               margin_type;                 // margin controlling type { MARGIN_TYPE_PERCENT,  MARGIN_TYPE_CURRENCY }
												   //--- archives
	int               archive_period;              // inactivity period after which account moves to archive base (in days)
	int               archive_max_balance;         // maxumum balance of accounts to move in archive base
	//---
	int               stopout_skip_hedged;         // skip fully hedged accounts when checking for stopout
	int               archive_pending_period;      // pendings clean period
	//--- allowed news languages
	List<unsigned int>^ news_languages;           // LANGID array
	UINT              news_languages_total;        // news languages total
	

};

//--- margin calculation mode
public enum class MarginCalculationModes{ MARGIN_MODE_DONT_USE, MARGIN_MODE_USE_ALL, MARGIN_MODE_USE_PROFIT, MARGIN_MODE_USE_LOSS };
//--- margin controlling type
public enum class MarginTypes { MARGIN_TYPE_PERCENT, MARGIN_TYPE_CURRENCY };
//--- news mode-no news, only topics, full news (topic+body)
public enum class NewsModes { NEWS_NO, NEWS_TOPICS, NEWS_FULL };
//--- group rights
public enum class GroupRights
{
	ALLOW_FLAG_EMAIL = 1,
	ALLOW_FLAG_TRAILING = 2,
	ALLOW_FLAG_ADVISOR = 4,
	ALLOW_FLAG_EXPIRATION = 8,
	ALLOW_FLAG_SIGNALS_ALL = 16,
	ALLOW_FLAG_SIGNALS_OWN = 32,
	ALLOW_FLAG_RISK_WARNING = 64,
	ALLOW_FLAG_FORCED_OTP_USAGE = 128,
};
//--- group one-time password mode
public enum class OneTimePasswordMode
{
	OTP_MODE_DISABLED = 0,
	OTP_MODE_TOTP_SHA256 = 1,
};

//+------------------------------------------------------------------+
//| Hollidays configuration                                          |
//+------------------------------------------------------------------+
[Serializable]
public value class ConHoliday
{
public:
	ConHoliday(MetaQuotes::ConHoliday& con) {
	
		year = con.year;                        // year
		month = con.month;                       // month
		day = con.day;                         // day
		from, to = con.from;                     // work time-from & to (minutes)
		symbol = Marshal::PtrToStringAnsi(IntPtr(con.symbol));                  // security name or symbol's group name or "All"
		description = Marshal::PtrToStringAnsi(IntPtr(con.description));            // description
		enable = con.enable;                      // enable
	
	}

	ConHoliday(MetaQuotes::ConHoliday* con) {

		year = con->year;                        // year
		month = con->month;                       // month
		day = con->day;                         // day
		from, to = con->from;                     // work time-from & to (minutes)
		symbol = Marshal::PtrToStringAnsi(IntPtr(con->symbol));                  // security name or symbol's group name or "All"
		description = Marshal::PtrToStringAnsi(IntPtr(con->description));            // description
		enable = con->enable;                      // enable

	}

	void ToMT4(MetaQuotes::ConHoliday* Con) {
		Con->year = year;
		Con->month = month;
		Con->day = day;
		Con->from = from;
		Con->to = to;
		IntPtr temp_symbol;
		char* temp;
		temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
		temp = (char*)temp_symbol.ToPointer();
		if (temp != NULL)
		strcpy(Con->symbol, (char *)(void *)temp_symbol);
		Marshal::FreeHGlobal(temp_symbol);
		IntPtr temp_description;
		temp_description = Marshal::StringToHGlobalAnsi(description);
		temp = (char*)temp_description.ToPointer();
		if (temp != NULL)
		strcpy(Con->description, (char *)(void *)temp_description);
		Marshal::FreeHGlobal(temp_description);
		Con->enable = enable;
	}

	int               year;                        // year
	int               month;                       // month
	int               day;                         // day
	int               from, to;                     // work time-from & to (minutes)
	String            ^symbol;                  // security name or symbol's group name or "All"
	String            ^description;            // description
	int               enable;                      // enable
	
};
//+------------------------------------------------------------------+
//| LiveUpdate configuration                                         |
//+------------------------------------------------------------------+

//---
[Serializable]
public value class LiveInfoFile
{
public:
	
	LiveInfoFile(MetaQuotes::LiveInfoFile& live) {
		file = Marshal::PtrToStringAnsi(IntPtr(live.file));
		size = live.size;
		hash = Marshal::PtrToStringAnsi(IntPtr(live.hash));
	
	}

	LiveInfoFile(MetaQuotes::LiveInfoFile* live) {
		file = Marshal::PtrToStringAnsi(IntPtr(live->file));
		size = live->size;
		hash = Marshal::PtrToStringAnsi(IntPtr(live->hash));

	}


	void ToMT4(MetaQuotes::LiveInfoFile* Liv) {
		IntPtr temp_file;
		char* temp;
		temp_file = Marshal::StringToHGlobalAnsi(file);
		temp = (char*)temp_file.ToPointer();
		if (temp != NULL)
		strcpy(Liv->file, (char *)(void *)temp_file);
		Marshal::FreeHGlobal(temp_file);
		Liv->size = size;
		IntPtr temp_hash;
		temp_hash = Marshal::StringToHGlobalAnsi(hash);
		temp = (char*)temp_hash.ToPointer();
		if (temp != NULL)
		strcpy(Liv->hash, (char *)(void *)temp_hash);
		Marshal::FreeHGlobal(temp_hash);
	}

	String            ^file;                   // file name
	int               size;                        // file size
	String            ^hash;                    // file hash

};

//---
[Serializable]
public value class  ConLiveUpdate
{
public:

	ConLiveUpdate(MetaQuotes::ConLiveUpdate &con) {
		company = Marshal::PtrToStringAnsi(IntPtr(con.company));
		path = Marshal::PtrToStringAnsi(IntPtr(con.path));
		version = con.version;
		build = con.build;
		maxconnect = con.maxconnect;
		connections = con.connections;
		type = con.type;
		enable = con.enable;
		totalfiles = con.totalfiles;
		files = gcnew List<LiveInfoFile>();
		for (int i = 0; i < con.totalfiles; i++)
			files->Add( LiveInfoFile(con.files[i]));

	}

	ConLiveUpdate(MetaQuotes::ConLiveUpdate* con) {
		company = Marshal::PtrToStringAnsi(IntPtr(con->company));
		path = Marshal::PtrToStringAnsi(IntPtr(con->path));
		version = con->version;
		build = con->build;
		maxconnect = con->maxconnect;
		connections = con->connections;
		type = con->type;
		enable = con->enable;
		totalfiles = con->totalfiles;
		files = gcnew List<LiveInfoFile>();
		for (int i = 0; i < con->totalfiles; i++)
			files->Add(LiveInfoFile(con->files[i]));

	}

	void ToMT4(MetaQuotes::ConLiveUpdate* Con) {
		IntPtr temp_company;
		char* temp;
		temp_company = Marshal::StringToHGlobalAnsi(company);
		temp = (char*)temp_company.ToPointer();
		if (temp != NULL)
		strcpy(Con->company, (char *)(void *)temp_company);
		Marshal::FreeHGlobal(temp_company);
		IntPtr temp_path;
		temp_path = Marshal::StringToHGlobalAnsi(path);
		temp = (char*)temp_path.ToPointer();
		if (temp != NULL)
		strcpy(Con->path, (char *)(void *)temp_path);
		Marshal::FreeHGlobal(temp_path);
		Con->version = version;
		Con->build = build;
		Con->maxconnect = maxconnect;
		Con->connections = connections;
		Con->type = type;
		Con->enable = enable;
		Con->totalfiles = totalfiles;
		for (int i = 0; i < files->Count; i++) {
			files[i].ToMT4(&Con->files[i]);
		}
	}

	String            ^company;                // company
	String            ^path;                   // path to LiveUpdate
	int               version;                     // version
	int               build;                       // build
	int               maxconnect;                  // max. simultaneous connections
	int               connections;                 // current connections (read only)
	int               type;                        // type LIVE_UPDATE_*
	int               enable;                      // enable
	int               totalfiles;                  // total files count
	List<LiveInfoFile>^ files;       // files' configurations
	
};

//--- LiveUpdate type
public enum class LiveUpdateTypes
{
	LIVE_UPDATE_CLIENT,
	LIVE_UPDATE_MANAGER,
	LIVE_UPDATE_ADMIN,
	LIVE_UPDATE_DATACENTER,
	LIVE_UPDATE_CLIENT_PPC2002,
	LIVE_UPDATE_CLIENT_PPC2003,
	LIVE_UPDATE_MULTI,
	LIVE_UPDATE_WD,
	LIVE_UPDATE_CLIENT_PHONE,
	LIVE_UPDATE_LAST
};

//+------------------------------------------------------------------+
//| Manager rights for security groups                               |
//+------------------------------------------------------------------+
[Serializable]
public value class   ConManagerSec
{
public:
	
	ConManagerSec(MetaQuotes::ConManagerSec &con) {
		internal = con.internal;
		enable = con.enable;
		minimum_lots = con.minimum_lots;
		maximum_lots = con.maximum_lots;

	}

	ConManagerSec(MetaQuotes::ConManagerSec* con) {
		internal = con->internal;
		enable = con->enable;
		minimum_lots = con->minimum_lots;
		maximum_lots = con->maximum_lots;

	}
	void ToMT4(MetaQuotes::ConManagerSec* Con) {
		Con->internal = internal;
		Con->enable = enable;
		Con->minimum_lots = minimum_lots;
		Con->maximum_lots = maximum_lots;
	}

	int               internal;                    // internal data
	int               enable;                      // enable
	int               minimum_lots;                // min. lots
	int               maximum_lots;                // max. lots

};
//+------------------------------------------------------------------+
//| Manager configuration                                            |
//+------------------------------------------------------------------+
[Serializable]
public value class   ConManager
{
public:

	ConManager(MetaQuotes::ConManager& con) {

		login = con.login;                       // login
												 //--- rights
		manager = con.manager;                     // right to add & change client records
		money = con.money;                       // right to balance & credit management
		online = con.online;                      // right to see online users
		riskman = con.riskman;                     // right to use analyzer
		broker = con.broker;                      // right to deal
		admin = con.admin;                       // right to server administration
		logs = con.logs;                        // right to see logs
		reports = con.reports;                     // right to see reports
		trades = con.trades;                      // right to add/modify/delete trades
		market_watch = con.market_watch;                // right to change spread, spread balance, stop levels, execution mode and send quotes
		email = con.email;                       // right to send ernal mail
		user_details = con.user_details;                // right to see clients private data-name,country,address,phone,email etc.
		see_trades = con.see_trades;                  // right to see trades
		news = con.news;                        // right to send news
		plugins = con.plugins;                     // right to configure plugins
		server_reports = con.server_reports;              // right to receive server reports
		techsupport = con.techsupport;                 // right to access to technical support page
		market = con.market;                      // right to access server applications market
		notifications = con.notifications;               // right to push notifications

														 //--- IP filtration
		ipfilter = con.ipfilter;                    // enable IP control
		ip_from = con.ip_from;
		ip_to = con.ip_to;               // range of allowed IPs
										 //---
		mailbox = Marshal::PtrToStringAnsi(IntPtr(con.mailbox));                // name of mailbox for ernal mail
		groups = Marshal::PtrToStringAnsi(IntPtr(con.groups));                 // comma separated list of managed groups (allowed '*' wildcard)
		secgroups = gcnew List<ConManagerSec>();// manager rights for security groups
		for (int i = 0; i < MAX_SEC_GROUPS; i++)
			secgroups->Add(ConManagerSec(con.secgroups[i]));
		exp_time = con.exp_time;                    // ernal data
		name = Marshal::PtrToStringAnsi(IntPtr(con.name));                    // manager name (read only)
		info_depth = con.info_depth;                  // maximum available data (in days) 

	}

	ConManager(MetaQuotes::ConManager* con) {

		login = con->login;                       // login
												  //--- rights
		manager = con->manager;                     // right to add & change client records
		money = con->money;                       // right to balance & credit management
		online = con->online;                      // right to see online users
		riskman = con->riskman;                     // right to use analyzer
		broker = con->broker;                      // right to deal
		admin = con->admin;                       // right to server administration
		logs = con->logs;                        // right to see logs
		reports = con->reports;                     // right to see reports
		trades = con->trades;                      // right to add/modify/delete trades
		market_watch = con->market_watch;                // right to change spread, spread balance, stop levels, execution mode and send quotes
		email = con->email;                       // right to send ernal mail
		user_details = con->user_details;                // right to see clients private data-name,country,address,phone,email etc.
		see_trades = con->see_trades;                  // right to see trades
		news = con->news;                        // right to send news
		plugins = con->plugins;                     // right to configure plugins
		server_reports = con->server_reports;              // right to receive server reports
		techsupport = con->techsupport;                 // right to access to technical support page
		market = con->market;                      // right to access server applications market
		notifications = con->notifications;               // right to push notifications

														  //--- IP filtration
		ipfilter = con->ipfilter;                    // enable IP control
		ip_from = con->ip_from;
		ip_to = con->ip_to;               // range of allowed IPs
										  //---
		mailbox = Marshal::PtrToStringAnsi(IntPtr(con->mailbox));                // name of mailbox for ernal mail
		groups = Marshal::PtrToStringAnsi(IntPtr(con->groups));                 // comma separated list of managed groups (allowed '*' wildcard)

		secgroups = gcnew List<ConManagerSec>();// manager rights for security groups
		for (int i = 0; i < MAX_SEC_GROUPS; i++)
			secgroups->Add(ConManagerSec(con->secgroups[i]));
		exp_time = con->exp_time;                    // ernal data
		name = Marshal::PtrToStringAnsi(IntPtr(con->name));                    // manager name (read only)
		info_depth = con->info_depth;                  // maximum available data (in days) 

	}


	void ToMT4(MetaQuotes::ConManager* Con) {
		Con->login = login;
		Con->manager = manager;
		Con->money = money;
		Con->online = online;
		Con->riskman = riskman;
		Con->broker = broker;
		Con->admin = admin;
		Con->logs = logs;
		Con->reports = reports;
		Con->trades = trades;
		Con->market_watch = market_watch;
		Con->email = email;
		Con->user_details = user_details;
		Con->see_trades = see_trades;
		Con->news = news;
		Con->plugins = plugins;
		Con->server_reports = server_reports;
		Con->techsupport = techsupport;
		Con->market = market;
		Con->notifications = notifications;
		Con->ipfilter = ipfilter;
		Con->ip_from = ip_from;
		Con->ip_to = ip_to;
		IntPtr temp_mailbox;
		char* temp;
		temp_mailbox = Marshal::StringToHGlobalAnsi(mailbox);
		temp = (char*)temp_mailbox.ToPointer();
		if (temp != NULL)
		strcpy(Con->mailbox, (char *)(void *)temp_mailbox);
		Marshal::FreeHGlobal(temp_mailbox);
		IntPtr temp_groups;
		temp_groups = Marshal::StringToHGlobalAnsi(groups);
		temp = (char*)temp_groups.ToPointer();
		if (temp != NULL)
		strcpy(Con->groups, (char *)(void *)temp_groups);
		Marshal::FreeHGlobal(temp_groups);

		for (int i = 0; i < secgroups->Count; i++)
			secgroups[i].ToMT4(&Con->secgroups[i]);

		Con->exp_time = exp_time;
		IntPtr temp_name;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Con->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		Con->info_depth = info_depth;
	}


	int               login;                       // login
	//--- rights
	int               manager;                     // right to add & change client records
	int               money;                       // right to balance & credit management
	int               online;                      // right to see online users
	int               riskman;                     // right to use analyzer
	int               broker;                      // right to deal
	int               admin;                       // right to server administration
	int               logs;                        // right to see logs
	int               reports;                     // right to see reports
	int               trades;                      // right to add/modify/delete trades
	int               market_watch;                // right to change spread, spread balance, stop levels, execution mode and send quotes
	int               email;                       // right to send internal mail
	int               user_details;                // right to see clients private data-name,country,address,phone,email etc.
	int               see_trades;                  // right to see trades
	int               news;                        // right to send news
	int               plugins;                     // right to configure plugins
	int               server_reports;              // right to receive server reports
	int               techsupport;                 // right to access to technical support page
	int               market;                      // right to access server applications market
	int               notifications;               // right to push notifications
	
	//--- IP filtration
	int               ipfilter;                    // enable IP control
	unsigned long     ip_from, ip_to;               // range of allowed IPs
	//---
	String			  ^mailbox;                 // name of mailbox for internal mail
	String			  ^groups;                // comma separated list of managed groups (allowed '*' wildcard)
	List<ConManagerSec>	^secgroups;   // manager rights for security groups
	DWORD             exp_time;                    // internal data
	String			  ^name;                    // manager name (read only)
	int               info_depth;                  // maximum available data (in days) 
	
};
//+------------------------------------------------------------------+
//| Symbol configurations                                            |
//+------------------------------------------------------------------+
//| Symbol sessions configurations                                   |
//+------------------------------------------------------------------+
[Serializable]
public value class ConSession
{
public:
	ConSession(MetaQuotes::ConSession &con) {
		open_hour=con.open_hour;
		open_min = con.open_min;
		close_hour = con.close_hour;
		close_min = con.close_min;
		open = con.open;
		close = con.close;
	
	}

	ConSession(MetaQuotes::ConSession* con) {
		open_hour = con->open_hour;
		open_min = con->open_min;
		close_hour = con->close_hour;
		close_min = con->close_min;
		open = con->open;
		close = con->close;

	}

	void ToMT4(MetaQuotes::ConSession* Con) {
		Con->open_hour = open_hour;
		Con->open_min = open_min;
		Con->close_hour = close_hour;
		Con->close_min = close_min;
		Con->open = open;
		Con->close = close;
	}

	short             open_hour, open_min;          // session open  time: hour & minute
	short             close_hour, close_min;        // session close time: hour & minute
	int               open, close;                  // internal data
	
};
//---
[Serializable]
public ref class   ConSessions
{

	//---
public:
	List<ConSession> ^quote;                    // quote sessions
	List<ConSession> ^trade;                    // trade sessions
												   //---
	int               quote_overnight;             // internal data
	int               trade_overnight;             // internal data
	
	void ToMT4(MetaQuotes::ConSessions* Con) {
		for (int i = 0; i < quote->Count; i++) {
			quote[i].ToMT4(&Con->quote[i]);
		}
		for (int i = 0; i < trade->Count; i++) {
			trade[i].ToMT4(&Con->trade[i]);
		}
		Con->quote_overnight = quote_overnight;
		Con->trade_overnight = trade_overnight;
	}

};



//+------------------------------------------------------------------+
//| Symbol configuration                                             |
//+------------------------------------------------------------------+
//---
[Serializable]
public value class   ConSymbol
{

public:

	ConSymbol(MetaQuotes::ConSymbol &cs)
	{
		symbol = Marshal::PtrToStringAnsi(IntPtr(cs.symbol));
		description = Marshal::PtrToStringAnsi(IntPtr(cs.description));
		source = Marshal::PtrToStringAnsi(IntPtr(cs.source));
		currency = Marshal::PtrToStringAnsi(IntPtr(cs.currency));
		type = cs.type;
		digits = cs.digits;
		trade = cs.trade;
		
		background_color = cs.background_color;
		count = cs.count;
		count_original = cs.count_original;

		realtime = cs.realtime;
		starting = cs.starting;
		expiration = cs.expiration;
		sessions = gcnew System::Collections::Generic::List<ConSessions^>();
		for (int m = 0; m < 7; m++){
			
				ConSessions^ tempConfiguration = gcnew ConSessions();
				tempConfiguration->quote = gcnew List<ConSession>();
				tempConfiguration->trade = gcnew List<ConSession>();
				for (int i = 0; i < 3; i++)
					tempConfiguration->quote->Add(ConSession(cs.sessions[m].quote[i]));

				for (int i = 0; i < 3; i++)
					tempConfiguration->trade->Add(ConSession(cs.sessions[m].trade[i]));

			
			sessions->Insert(m, tempConfiguration);
		}
			

		profit_mode = cs.profit_mode;
		profit_reserved = cs.profit_reserved;

		filter = cs.filter;
		filter_counter = cs.filter_counter;
		filter_limit = cs.filter_limit;
		filter_smoothing = cs.filter_smoothing;
		filter_reserved = cs.filter_reserved;
		logging = cs.logging;

		spread = cs.spread;
		spread_balance = cs.spread_balance;
		exemode = cs.exemode;
		swap_enable = cs.swap_enable;
		swap_type = cs.swap_type;
		swap_long = cs.swap_long;
		swap_short = cs.swap_short;
		swap_rollover3days = cs.swap_rollover3days;
		contract_size = cs.contract_size;
		tick_value = cs.tick_value;
		tick_size = cs.tick_size;
		stops_level = cs.stops_level;

		gtc_pendings = cs.gtc_pendings;
		margin_mode = cs.margin_mode;
		margin_initial = cs.margin_initial;
		margin_maintenance = cs.margin_maintenance;
		margin_hedged = cs.margin_hedged;
		margin_divider = cs.margin_divider;

		point = cs.point;
		multiply = cs.multiply;
		bid_tickvalue = cs.bid_tickvalue;
		ask_tickvalue = cs.ask_tickvalue;

		long_only = cs.long_only;
		instant_max_volume = cs.instant_max_volume;

		margin_currency = Marshal::PtrToStringAnsi(IntPtr(cs.margin_currency));
		freeze_level = cs.freeze_level;
		margin_hedged_strong = cs.margin_hedged_strong;
		value_date = cs.value_date;
		quotes_delay = cs.quotes_delay;
		swap_openprice = cs.swap_openprice;
	}

	ConSymbol(MetaQuotes::ConSymbol* cs)
	{
		symbol = Marshal::PtrToStringAnsi(IntPtr(cs->symbol));
		description = Marshal::PtrToStringAnsi(IntPtr(cs->description));
		source = Marshal::PtrToStringAnsi(IntPtr(cs->source));
		currency = Marshal::PtrToStringAnsi(IntPtr(cs->currency));
		type = cs->type;
		digits = cs->digits;
		trade = cs->trade;

		background_color = cs->background_color;
		count = cs->count;
		count_original = cs->count_original;

		realtime = cs->realtime;
		starting = cs->starting;
		expiration = cs->expiration;
		sessions = gcnew System::Collections::Generic::List<ConSessions^>();
		for (int m = 0; m < 7; m++) {

			ConSessions^ tempConfiguration = gcnew ConSessions();
			tempConfiguration->quote = gcnew List<ConSession>();
			tempConfiguration->trade = gcnew List<ConSession>();

			for (int i = 0; i < 3; i++)
				tempConfiguration->quote->Add(ConSession(cs->sessions[m].quote[i]));

			for (int i = 0; i < 3; i++)
				tempConfiguration->trade->Add(ConSession(cs->sessions[m].trade[i]));


			sessions->Insert(m, tempConfiguration);
		}


		profit_mode = cs->profit_mode;
		profit_reserved = cs->profit_reserved;

		filter = cs->filter;
		filter_counter = cs->filter_counter;
		filter_limit = cs->filter_limit;
		filter_smoothing = cs->filter_smoothing;
		filter_reserved = cs->filter_reserved;
		logging = cs->logging;

		spread = cs->spread;
		spread_balance = cs->spread_balance;
		exemode = cs->exemode;
		swap_enable = cs->swap_enable;
		swap_type = cs->swap_type;
		swap_long = cs->swap_long;
		swap_short = cs->swap_short;
		swap_rollover3days = cs->swap_rollover3days;
		contract_size = cs->contract_size;
		tick_value = cs->tick_value;
		tick_size = cs->tick_size;
		stops_level = cs->stops_level;

		gtc_pendings = cs->gtc_pendings;
		margin_mode = cs->margin_mode;
		margin_initial = cs->margin_initial;
		margin_maintenance = cs->margin_maintenance;
		margin_hedged = cs->margin_hedged;
		margin_divider = cs->margin_divider;

		point = cs->point;
		multiply = cs->multiply;
		bid_tickvalue = cs->bid_tickvalue;
		ask_tickvalue = cs->ask_tickvalue;

		long_only = cs->long_only;
		instant_max_volume = cs->instant_max_volume;

		margin_currency = Marshal::PtrToStringAnsi(IntPtr(cs->margin_currency));
		freeze_level = cs->freeze_level;
		margin_hedged_strong = cs->margin_hedged_strong;
		value_date = cs->value_date;
		quotes_delay = cs->quotes_delay;
		swap_openprice = cs->swap_openprice;
	}

	void ToMT4(MetaQuotes::ConSymbol* Con) {
		IntPtr temp_symbol;
		char* temp;
		temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
		temp = (char*)temp_symbol.ToPointer();
		if (temp != NULL)
		strcpy(Con->symbol, (char *)(void *)temp_symbol);
		Marshal::FreeHGlobal(temp_symbol);
		IntPtr temp_description;
		temp_description = Marshal::StringToHGlobalAnsi(description);
		temp = (char*)temp_description.ToPointer();
		if (temp != NULL)
		strcpy(Con->description, (char *)(void *)temp_description);
		Marshal::FreeHGlobal(temp_description);
		IntPtr temp_source;
		temp_source = Marshal::StringToHGlobalAnsi(source);
		temp = (char*)temp_source.ToPointer();
		if (temp != NULL)
		strcpy(Con->source, (char *)(void *)temp_source);
		Marshal::FreeHGlobal(temp_source);
		IntPtr temp_currency;
		temp_currency = Marshal::StringToHGlobalAnsi(currency);
		temp = (char*)temp_currency.ToPointer();
		if (temp != NULL)
		strcpy(Con->currency, (char *)(void *)temp_currency);
		Marshal::FreeHGlobal(temp_currency);
		Con->type = type;
		Con->digits = digits;
		Con->trade = trade;
		Con->count = count;
		Con->count_original = count_original;
		Con->realtime = realtime;
		Con->starting = starting;
		Con->expiration = expiration;
		for (int i = 0; i < sessions->Count; i++) {
			sessions[i]->ToMT4(&Con->sessions[i]);
		}
		Con->profit_mode = profit_mode;
		Con->profit_reserved = profit_reserved;
		Con->filter = filter;
		Con->filter_counter = filter_counter;
		Con->filter_limit = filter_limit;
		Con->filter_smoothing = filter_smoothing;
		Con->logging = logging;
		Con->spread = spread;
		Con->spread_balance = spread_balance;
		Con->exemode = exemode;
		Con->swap_enable = swap_enable;
		Con->swap_type = swap_type;
		Con->swap_long = swap_long;
		Con->swap_short = swap_short;
		Con->swap_rollover3days = swap_rollover3days;
		Con->contract_size = contract_size;
		Con->tick_value = tick_value;
		Con->tick_size = tick_size;
		Con->stops_level = stops_level;
		Con->gtc_pendings = gtc_pendings;
		Con->margin_mode = margin_mode;
		Con->margin_initial = margin_initial;
		Con->margin_maintenance = margin_maintenance;
		Con->margin_hedged = margin_hedged;
		Con->margin_divider = margin_divider;
		Con->point = point;
		Con->multiply = multiply;
		Con->bid_tickvalue = bid_tickvalue;
		Con->ask_tickvalue = ask_tickvalue;
		Con->long_only = long_only;
		Con->instant_max_volume = instant_max_volume;
		IntPtr temp_margin_currency;
		temp_margin_currency = Marshal::StringToHGlobalAnsi(margin_currency);
		temp = (char*)temp_margin_currency.ToPointer();
		if (temp != NULL)
		strcpy(Con->margin_currency, (char *)(void *)temp_margin_currency);
		Marshal::FreeHGlobal(temp_margin_currency);
		Con->freeze_level = freeze_level;
		Con->margin_hedged_strong = margin_hedged_strong;
		Con->value_date = value_date;
		Con->quotes_delay = quotes_delay;
		Con->swap_openprice = swap_openprice;
		Con->swap_variation_margin = swap_variation_margin;
	}


	//--- common settings
	String			  ^symbol;                  // name
	String			  ^description;             // description
	String			  ^source;                  // synonym
	String			  ^currency;                // currency
	int               type;                        // security group (see ConSymbolGroup)
	int               digits;                      // security precision
	int               trade;                       // trade mode
												   //--- external settings
	COLORREF          background_color;            // background color
	int               count;                       // symbols index
	int               count_original;              // symbols index in market watch
	
	//--- sessions
	int               realtime;                    // allow real time quotes
	__time32_t        starting;                    // trades starting date (UNIX time)
	__time32_t        expiration;                  // trades end date      (UNIX time)
	List<ConSessions^>       ^sessions;                 // quote & trade sessions
												   //--- profits
	int               profit_mode;                 // profit calculation mode
	int               profit_reserved;             // reserved
												   //--- filtration
	int               filter;                      // filter value
	int               filter_counter;              // filtration parameter
	double            filter_limit;                // max. permissible deviation from last quote (percents)
	int               filter_smoothing;            // smoothing
	float             filter_reserved;             // reserved
	int               logging;                     // enable to log quotes
												   //--- spread & swaps
	int               spread;                      // spread
	int               spread_balance;              // spread balance
	int               exemode;                     // execution mode
	int               swap_enable;                 // enable swaps
	int               swap_type;                   // swap type
	double            swap_long, swap_short;        // swaps values for long & short postions
	int               swap_rollover3days;          // triple rollover day-0-Monday,1-Tuesday...4-Friday
	double            contract_size;               // contract size
	double            tick_value;                  // one tick value
	double            tick_size;                   // one tick size
	int               stops_level;                 // stops deviation value
												   //---            îâåðíàéòû è ïðî÷èå ñâîïû
	int               gtc_pendings;                // GTC mode { ORDERS_DAILY, ORDERS_GTC, ORDERS_DAILY_NO_STOPS }
												   //--- margin calculation
	int               margin_mode;                 // margin calculation mode
	double            margin_initial;              // initial margin
	double            margin_maintenance;          // margin maintenance
	double            margin_hedged;               // hedged margin
	double            margin_divider;              // margin divider
												   //--- calclulated variables (internal data)
	double            point;                       // point size-(1/(10^digits)
	double            multiply;                    // multiply 10^digits
	double            bid_tickvalue;               // tickvalue for bid
	double            ask_tickvalue;               // tickvalue for ask
												   //---
	int               long_only;                   // allow only BUY positions
	int               instant_max_volume;          // max. volume for Instant Execution
												   //---
	String			  ^margin_currency;         // currency of margin requirments
	int               freeze_level;                // modification freeze level
	int               margin_hedged_strong;        // strong hedged margin mode
	__time32_t        value_date;                  // value date
	int               quotes_delay;                // quotes delay after session start
	int               swap_openprice;         	  // use open price at swaps calculation in SWAP_BY_INTEREST mode
	int               swap_variation_margin;       // charge variation margin on rollover


};
//+------------------------------------------------------------------+
//| Symbols enumeration                                              |
//+------------------------------------------------------------------+
//--- symbol execution mode
enum { EXE_REQUEST, EXE_INSTANT, EXE_MARKET };
//--- trade mode
enum { TRADE_NO, TRADE_CLOSE, TRADE_FULL };
//--- swap type
enum { SWAP_BY_POINTS, SWAP_BY_DOLLARS, SWAP_BY_INTEREST, SWAP_BY_MARGIN_CURRENCY };
//--- profit calculation mode
enum { PROFIT_CALC_FOREX, PROFIT_CALC_CFD, PROFIT_CALC_FUTURES };
//--- margin calculation mode
enum { MARGIN_CALC_FOREX, MARGIN_CALC_CFD, MARGIN_CALC_FUTURES, MARGIN_CALC_CFDINDEX, MARGIN_CALC_CFDLEVERAGE };
//--- GTC mode
enum { ORDERS_DAILY, ORDERS_GTC, ORDERS_DAILY_NO_STOPS };
//+------------------------------------------------------------------+
//| Symbol groups                                                    |
//+------------------------------------------------------------------+
[Serializable]
public value class   ConSymbolGroup
{
public:
	ConSymbolGroup(MetaQuotes::ConSymbolGroup &csg)
	{
		name = Marshal::PtrToStringAnsi(IntPtr(csg.name));
		description = Marshal::PtrToStringAnsi(IntPtr(csg.description));
	}
	ConSymbolGroup(MetaQuotes::ConSymbolGroup* csg)
	{
		name = Marshal::PtrToStringAnsi(IntPtr(csg->name));
		description = Marshal::PtrToStringAnsi(IntPtr(csg->description));
	}

	void ToMT4(MetaQuotes::ConSymbolGroup* Con) {
		IntPtr temp_name;
		char* temp;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Con->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		IntPtr temp_description;
		temp_description = Marshal::StringToHGlobalAnsi(description);
		temp = (char*)temp_description.ToPointer();
		if (temp != NULL)
		strcpy(Con->description, (char *)(void *)temp_description);
		Marshal::FreeHGlobal(temp_description);
		
	}

	String			  ^name;                     // group name
	String			  ^description;              // group description
	int index;
};
//+------------------------------------------------------------------+
//| Synchronization configuration                                    |
//+------------------------------------------------------------------+
[Serializable]
public value class   ConSync
{
public:
	ConSync(MetaQuotes::ConSync& con) {
		server = Marshal::PtrToStringAnsi(IntPtr(con.server));
		unusedport = con.unusedport;
		login = Marshal::PtrToStringAnsi(IntPtr(con.login));
		password = Marshal::PtrToStringAnsi(IntPtr(con.password));
		enable = con.enable;
		mode = con.mode;
		from = con.from;
		to = con.to;
		securities = Marshal::PtrToStringAnsi(IntPtr(con.securities));
		timecorrection = con.timecorrection;
	
	}

	ConSync(MetaQuotes::ConSync* con) {
		server = Marshal::PtrToStringAnsi(IntPtr(con->server));
		unusedport = con->unusedport;
		login = Marshal::PtrToStringAnsi(IntPtr(con->login));
		password = Marshal::PtrToStringAnsi(IntPtr(con->password));
		enable = con->enable;
		mode = con->mode;
		from = con->from;
		to = con->to;
		securities = Marshal::PtrToStringAnsi(IntPtr(con->securities));
		timecorrection = con->timecorrection;
		
	}


	void ToMT4(MetaQuotes::ConSync* Con) {
		IntPtr temp_server;
		char* temp;
		temp_server = Marshal::StringToHGlobalAnsi(server);
		temp = (char*)temp_server.ToPointer();
		if (temp != NULL)
		strcpy(Con->server, (char *)(void *)temp_server);
		Marshal::FreeHGlobal(temp_server);
		Con->unusedport = unusedport;
		IntPtr temp_login;
		temp_login = Marshal::StringToHGlobalAnsi(login);
		temp = (char*)temp_login.ToPointer();
		if (temp != NULL)
		strcpy(Con->login, (char *)(void *)temp_login);
		Marshal::FreeHGlobal(temp_login);
		IntPtr temp_password;
		temp_password = Marshal::StringToHGlobalAnsi(password);
		temp = (char*)temp_password.ToPointer();
		if (temp != NULL)
		strcpy(Con->password, (char *)(void *)temp_password);
		Marshal::FreeHGlobal(temp_password);
		Con->enable = enable;
		Con->mode = mode;
		Con->from = from;
		Con->to = to;
		IntPtr temp_securities;
		temp_securities = Marshal::StringToHGlobalAnsi(securities);
		temp = (char*)temp_securities.ToPointer();
		if (temp != NULL)
		strcpy(Con->securities, (char *)(void *)temp_securities);
		Marshal::FreeHGlobal(temp_securities);
		Con->timecorrection = timecorrection;
		
	}



	String			  ^server;                   // name (address
	int               unusedport;                   // port
	String			  ^login;                    // for future use-login
	String			  ^password;                 // for future use=password
	int               enable;                       // enable sychronization
	int               mode;                         // synchronization mode: HB_ADD,HB_UPDATE,HB_INSERT
	__time32_t        from, to;                      // synchronization range (<0-whole chart)
	String			  ^securities;             // symbols list
	int               timecorrection;               // time correction in minutes
	
	
};
//--- synchronization mode
enum { HB_ADD, HB_UPDATE, HB_INSERT, HB_DELETE, HB_LAST };
//+------------------------------------------------------------------+
//| Plugin configuration                                             |
//+------------------------------------------------------------------+
//| Plugin description                                               |
//+------------------------------------------------------------------+
[Serializable]
public value class   PluginInfo
{
public:
	
	PluginInfo(MetaQuotes::PluginInfo& plg) {
		name = Marshal::PtrToStringAnsi(IntPtr(plg.name));
		version = plg.version;
		copyright = Marshal::PtrToStringAnsi(IntPtr(plg.copyright));
	}
	PluginInfo(MetaQuotes::PluginInfo* plg) {
		name = Marshal::PtrToStringAnsi(IntPtr(plg->name));
		version = plg->version;
		copyright = Marshal::PtrToStringAnsi(IntPtr(plg->copyright));
	}


	void ToMT4(MetaQuotes::PluginInfo* Plu) {
		IntPtr temp_name;
		char* temp;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Plu->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		Plu->version = version;
		IntPtr temp_copyright;
		temp_copyright = Marshal::StringToHGlobalAnsi(copyright);
		temp = (char*)temp_copyright.ToPointer();
		if (temp != NULL)
		strcpy(Plu->copyright, (char *)(void *)temp_copyright);
		Marshal::FreeHGlobal(temp_copyright);
	}


	String			  ^name;                    // plugin name
	unsigned int      version;                      // plugin version
	String			  ^copyright;               // plugin copyright
	
};
//+------------------------------------------------------------------+
//| Plugin configuration parameter                                   |
//+------------------------------------------------------------------+
[Serializable]
public ref class   PluginCfg
{
public:
	
	PluginCfg(MetaQuotes::PluginCfg &plg) {
		name = Marshal::PtrToStringAnsi(IntPtr(plg.name));
		value = Marshal::PtrToStringAnsi(IntPtr(plg.value));
	}

	PluginCfg(MetaQuotes::PluginCfg* plg) {
		name = Marshal::PtrToStringAnsi(IntPtr(plg->name));
		value = Marshal::PtrToStringAnsi(IntPtr(plg->value));
	}


	void ToMT4(MetaQuotes::PluginCfg* Plu) {
		IntPtr temp_name;
		char* temp;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Plu->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		IntPtr temp_value;
		temp_value = Marshal::StringToHGlobalAnsi(value);
		temp = (char*)temp_value.ToPointer();
		if (temp != NULL)
		strcpy(Plu->value, (char *)(void *)temp_value);
		Marshal::FreeHGlobal(temp_value);
	}

	String			  ^name;                     // parameter name
	String			  ^value;                   // parameter value
	
};
//+------------------------------------------------------------------+
//| Plugin configuration                                             |
//+------------------------------------------------------------------+
[Serializable]
public value class   ConPlugin
{
public:
	
	
	ConPlugin(MetaQuotes::ConPlugin& plg) {
		file = Marshal::PtrToStringAnsi(IntPtr(plg.file));
		info = PluginInfo(plg.info);
		enabled = plg.enabled;
		configurable = plg.configurable;
		manager_access = plg.manager_access;
	}

	ConPlugin(MetaQuotes::ConPlugin* plg) {
		file = Marshal::PtrToStringAnsi(IntPtr(plg->file));
		info = PluginInfo(plg->info);
		enabled = plg->enabled;
		configurable = plg->configurable;
		manager_access = plg->manager_access;
	}

	void ToMT4(MetaQuotes::ConPlugin* Con) {
		IntPtr temp_file;
		char* temp;
		temp_file = Marshal::StringToHGlobalAnsi(file);
		temp = (char*)temp_file.ToPointer();
		if (temp != NULL)
		strcpy(Con->file, (char *)(void *)temp_file);
		Marshal::FreeHGlobal(temp_file);
		Con->enabled = enabled;
		Con->configurable = configurable;
		Con->manager_access = manager_access;
	}

	String			  ^file;                    // plugin file name
	PluginInfo        ^info;                         // plugin description
	int               enabled;                      // plugin enabled/disabled
	int               configurable;                 // is plugin configurable
	int               manager_access;               // plugin can be accessed from manager terminal
	
};

//--- plugin with parameters
[Serializable]
public value class ConPluginParam
{
public:

	ConPlugin^        plugin;                       // plugin configuration
	System::Collections::Generic::IList<PluginCfg^> ^params;                      // plugin parameters
	int               total;                        // total plugin parameters


	ConPluginParam(MetaQuotes::ConPluginParam &parm) {
		plugin = ConPlugin(parm.plugin);
		total = parm.total;

		params = gcnew List<PluginCfg^>();
		for (int i = 0; i < parm.total; i++) {
			PluginCfg^ sec = gcnew PluginCfg(Helpers::Helper::GetParameters(&parm, i));
			params->Add(sec);
		}	

	}

	ConPluginParam(MetaQuotes::ConPluginParam *parm) {
		plugin = ConPlugin(parm->plugin);
		total = parm->total;

		params = gcnew List<PluginCfg^>();
		for (int i = 0; i < parm->total; i++) {
			PluginCfg^ sec = gcnew PluginCfg(Helpers::Helper::GetParameters(parm, i));
			params->Add(sec);
		}
	}


	void ToMT4(MetaQuotes::ConPluginParam* Con) {
		
		for (int i = 0; i < params->Count; i++) {
			Helpers::Helper::FillParameters(Con, Helpers::Helper::GetParameters(Con,i), i);
		}
		 plugin->ToMT4(&Con->plugin);
		Con->total = total;
	}


};
//+------------------------------------------------------------------+
//| Gateway configuration                                            |
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| Gateway account configuration                                    |
//+------------------------------------------------------------------+
[Serializable]
public value class ConGatewayAccount
{
public:

	int enable;     // enable flag 0 - disabled, 1 - enabled
	String ^name;    // public name
	int id;       // internal id
	int type;      // type (obsolete)
	int login;     // STP MT4 login
	String ^address;  // MT4 server address
	String ^password;  // STP MT4 password
	List<int> ^notify_logins;       // list of logins for internal email notification
	int flags;     // flag fields

	ConGatewayAccount(MetaQuotes::ConGatewayAccount& Con) {
		enable = Con.enable;
		name = Marshal::PtrToStringAnsi(IntPtr(Con.name));
		id = Con.id;
		type = Con.type;
		login = Con.login;
		address = Marshal::PtrToStringAnsi(IntPtr(Con.address));
		password = Marshal::PtrToStringAnsi(IntPtr(Con.password));
		flags = Con.flags;
	}

	ConGatewayAccount(MetaQuotes::ConGatewayAccount* Con) {
		enable = Con->enable;
		name = Marshal::PtrToStringAnsi(IntPtr(Con->name));
		id = Con->id;
		type = Con->type;
		login = Con->login;
		address = Marshal::PtrToStringAnsi(IntPtr(Con->address));
		password = Marshal::PtrToStringAnsi(IntPtr(Con->password));
		flags = Con->flags;
	}



	void ToMT4(MetaQuotes::ConGatewayAccount* Con) {
		Con->enable = enable;
		IntPtr temp_name;
		char* temp;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Con->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		Con->id = id;
		Con->type = type;
		Con->login = login;
		IntPtr temp_address;
		temp_address = Marshal::StringToHGlobalAnsi(address);
		temp = (char*)temp_address.ToPointer();
		if (temp != NULL)
		strcpy(Con->address, (char *)(void *)temp_address);
		Marshal::FreeHGlobal(temp_address);
		IntPtr temp_password;
		temp_password = Marshal::StringToHGlobalAnsi(password);
		temp = (char*)temp_password.ToPointer();
		if (temp != NULL)
		strcpy(Con->password, (char *)(void *)temp_password);
		Marshal::FreeHGlobal(temp_password);
		for (int i = 0; i < 8; i++) {
			Con->notify_logins[i] = notify_logins[i];
		}
		Con->flags = flags;
	}

};
//--- gateway account flags
enum EnGatewayAccountFlags { GATEWAY_FLAG_NONE = 0, GATEWAY_FLAG_QUOTES = 1 };
//+------------------------------------------------------------------+
//| Gateway markup configuration                                     |
//+------------------------------------------------------------------+
[Serializable]
public value class ConGatewayMarkup
{
public:
	int enable;     // enable flag 0 - disabled, 1 - enabled
	String ^source;  // source symbol\symbols mask\symbols group name
	String ^symbol;   // local symbol name
	String ^account_name;       // account name (obsolete)
	int account_id;   // account internal id (obsolete)
	int bid_markup;   // bid markup in pips
	int ask_markup;   // ask markup in pips

	ConGatewayMarkup(MetaQuotes::ConGatewayMarkup& Con) {
		enable = Con.enable;
		source = Marshal::PtrToStringAnsi(IntPtr(Con.source));
		symbol = Marshal::PtrToStringAnsi(IntPtr(Con.symbol));
		account_name = Marshal::PtrToStringAnsi(IntPtr(Con.account_name));
		account_id = Con.account_id;
		bid_markup = Con.bid_markup;
		ask_markup = Con.ask_markup;
	}

	ConGatewayMarkup(MetaQuotes::ConGatewayMarkup* Con) {
		enable = Con->enable;
		source = Marshal::PtrToStringAnsi(IntPtr(Con->source));
		symbol = Marshal::PtrToStringAnsi(IntPtr(Con->symbol));
		account_name = Marshal::PtrToStringAnsi(IntPtr(Con->account_name));
		account_id = Con->account_id;
		bid_markup = Con->bid_markup;
		ask_markup = Con->ask_markup;
	}

	void ToMT4(MetaQuotes::ConGatewayMarkup* Con) {
		Con->enable = enable;
		IntPtr temp_source;
		char* temp;
		temp_source = Marshal::StringToHGlobalAnsi(source);
		temp = (char*)temp_source.ToPointer();
		if (temp != NULL)
		strcpy(Con->source, (char *)(void *)temp_source);
		Marshal::FreeHGlobal(temp_source);
		IntPtr temp_symbol;
		temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
		temp = (char*)temp_symbol.ToPointer();
		if (temp != NULL)
		strcpy(Con->symbol, (char *)(void *)temp_symbol);
		Marshal::FreeHGlobal(temp_symbol);
		IntPtr temp_account_name;
		temp_account_name = Marshal::StringToHGlobalAnsi(account_name);
		temp = (char*)temp_account_name.ToPointer();
		if (temp != NULL)
		strcpy(Con->account_name, (char *)(void *)temp_account_name);
		Marshal::FreeHGlobal(temp_account_name);
		Con->account_id = account_id;
		Con->bid_markup = bid_markup;
		Con->ask_markup = ask_markup;
	}

};
//+------------------------------------------------------------------+
//| Gateway rules configuration                                      |
//+------------------------------------------------------------------+
[Serializable]
public value class ConGatewayRule
{
public:
	int enable;     // enable flag 0 - disabled, 1 - enabled
	String ^name;    // public name
	String ^request_symbol;     // symbol\symbols mask\symbols group name
	String ^request_group;      // group name or group mask
	List<int> ^request_reserved;     // reserved
	String ^exe_account_name;     // account name
	int exe_account_id; // account internal id
	int exe_max_deviation;      // max. devation
	int exe_max_profit_slippage;   // max profit slippage in pips
	int exe_max_profit_slippage_lots; // max profit slippage volume in lots
	int exe_max_losing_slippage;   // max losing slippage in pips
	int exe_max_losing_slippage_lots; // max losing slippage volume in lots
	int exe_account_pos;       // account current position
	int exe_volume_percent;      // coverage percentage

	ConGatewayRule(MetaQuotes::ConGatewayRule& Con) {
		enable = Con.enable;
		name = Marshal::PtrToStringAnsi(IntPtr(Con.name));
		request_symbol = Marshal::PtrToStringAnsi(IntPtr(Con.request_symbol));
		request_group = Marshal::PtrToStringAnsi(IntPtr(Con.request_group));
		exe_account_name = Marshal::PtrToStringAnsi(IntPtr(Con.exe_account_name));
		exe_account_id = Con.exe_account_id;
		exe_max_deviation = Con.exe_max_deviation;
		exe_max_profit_slippage = Con.exe_max_profit_slippage;
		exe_max_profit_slippage_lots = Con.exe_max_profit_slippage_lots;
		exe_max_losing_slippage = Con.exe_max_losing_slippage;
		exe_max_losing_slippage_lots = Con.exe_max_losing_slippage_lots;
		exe_account_pos = Con.exe_account_pos;
		exe_volume_percent = Con.exe_volume_percent;
	}

	ConGatewayRule(MetaQuotes::ConGatewayRule* Con) {
		enable = Con->enable;
		name = Marshal::PtrToStringAnsi(IntPtr(Con->name));
		request_symbol = Marshal::PtrToStringAnsi(IntPtr(Con->request_symbol));
		request_group = Marshal::PtrToStringAnsi(IntPtr(Con->request_group));
		exe_account_name = Marshal::PtrToStringAnsi(IntPtr(Con->exe_account_name));
		exe_account_id = Con->exe_account_id;
		exe_max_deviation = Con->exe_max_deviation;
		exe_max_profit_slippage = Con->exe_max_profit_slippage;
		exe_max_profit_slippage_lots = Con->exe_max_profit_slippage_lots;
		exe_max_losing_slippage = Con->exe_max_losing_slippage;
		exe_max_losing_slippage_lots = Con->exe_max_losing_slippage_lots;
		exe_account_pos = Con->exe_account_pos;
		exe_volume_percent = Con->exe_volume_percent;
	}

	void ToMT4(MetaQuotes::ConGatewayRule* Con) {
		Con->enable = enable;
		IntPtr temp_name;
		char* temp;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Con->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		IntPtr temp_request_symbol;
		temp_request_symbol = Marshal::StringToHGlobalAnsi(request_symbol);
		temp = (char*)temp_request_symbol.ToPointer();
		if (temp != NULL)
		strcpy(Con->request_symbol, (char *)(void *)temp_request_symbol);
		Marshal::FreeHGlobal(temp_request_symbol);
		IntPtr temp_request_group;
		temp_request_group = Marshal::StringToHGlobalAnsi(request_group);
		temp = (char*)temp_request_group.ToPointer();
		if (temp != NULL)
		strcpy(Con->request_group, (char *)(void *)temp_request_group);
		Marshal::FreeHGlobal(temp_request_group);
		for (int i = 0; i < request_reserved->Count; i++) {
			Con->request_reserved[i] = request_reserved[i];
		}
		IntPtr temp_exe_account_name;
		temp_exe_account_name = Marshal::StringToHGlobalAnsi(exe_account_name);
		temp = (char*)temp_exe_account_name.ToPointer();
		if (temp != NULL)
		strcpy(Con->exe_account_name, (char *)(void *)temp_exe_account_name);
		Marshal::FreeHGlobal(temp_exe_account_name);
		Con->exe_account_id = exe_account_id;
		Con->exe_max_deviation = exe_max_deviation;
		Con->exe_max_profit_slippage = exe_max_profit_slippage;
		Con->exe_max_profit_slippage_lots = exe_max_profit_slippage_lots;
		Con->exe_max_losing_slippage = exe_max_losing_slippage;
		Con->exe_max_losing_slippage_lots = exe_max_losing_slippage_lots;
		Con->exe_account_pos = exe_account_pos;
		Con->exe_volume_percent = exe_volume_percent;
	}

};

//+------------------------------------------------------------------+
//|                           Result codes                           |
//+------------------------------------------------------------------+
public enum class RetValues
{   //--- common errors
   RET_OK                =0,        // all OK
   RET_OK_NONE,                     // all OK-no operation
   RET_ERROR,                       // general error
   RET_INVALID_DATA,                // invalid data
   RET_TECH_PROBLEM,                // server technical problem
   RET_OLD_VERSION,                 // old client terminal
   RET_NO_CONNECT,                  // no connection
   RET_NOT_ENOUGH_RIGHTS,           // no enough rights
   RET_TOO_FREQUENT,                // too frequently access to server
   RET_MALFUNCTION,                 // mulfunctional operation
   RET_GENERATE_KEY,                // need to send public key
   RET_SECURITY_SESSION,            // security session start
   //--- account status
   RET_ACCOUNT_DISABLED  =64,       // account blocked
   RET_BAD_ACCOUNT_INFO,            // bad account info
   RET_PUBLIC_KEY_MISSING,          // îòñóòñòâóåò êëþ÷
   //--- trade
   RET_TRADE_TIMEOUT     =128,      // trade transatcion timeou expired
   RET_TRADE_BAD_PRICES,            // order has wrong prices
   RET_TRADE_BAD_STOPS,             // wrong stops level
   RET_TRADE_BAD_VOLUME,            // wrong lot size
   RET_TRADE_MARKET_CLOSED,         // market closed
   RET_TRADE_DISABLE,               // trade disabled
   RET_TRADE_NO_MONEY,              // no enough money for order execution
   RET_TRADE_PRICE_CHANGED,         // price changed
   RET_TRADE_OFFQUOTES,             // no quotes
   RET_TRADE_BROKER_BUSY,           // broker is busy
   RET_TRADE_REQUOTE,               // requote
   RET_TRADE_ORDER_LOCKED,          // order is proceed by dealer and cannot be changed
   RET_TRADE_LONG_ONLY,             // allowed only BUY orders
   RET_TRADE_TOO_MANY_REQ,          // too many requests from one client
   //--- order status notification
   RET_TRADE_ACCEPTED,              // trade request accepted by server and placed in request queue
   RET_TRADE_PROCESS,               // trade request accepted by dealerd
   RET_TRADE_USER_CANCEL,           // trade request canceled by client
   //--- additional return codes
   RET_TRADE_MODIFY_DENIED,         // trade modification denied
   RET_TRADE_CONTEXT_BUSY,          // trade context is busy (used in client terminal)
   RET_TRADE_EXPIRATION_DENIED,     // using expiration date denied
   RET_TRADE_TOO_MANY_ORDERS,       // too many orders
   RET_TRADE_HEDGE_PROHIBITED,      // hedge is prohibited
   RET_TRADE_PROHIBITED_BY_FIFO     // prohibited by fifo rule
};



//+------------------------------------------------------------------+
//| Pumping mode flags                                               |
//+------------------------------------------------------------------+
[Flags]
public enum class PumpingFlags : int
{
	//--- user flags
	CLIENT_FLAGS_HIDETICKS = 1,   // do not send ticks
	CLIENT_FLAGS_HIDENEWS = 2,   // do not send news
	CLIENT_FLAGS_HIDEMAIL = 4,   // do not send mails
	CLIENT_FLAGS_SENDFULLNEWS = 8,   // send news body with news header in pumping mode
	CLIENT_FLAGS_RESERVED = 16,  // reserved
								 //--- manager flags
								 CLIENT_FLAGS_HIDEONLINE = 32,  // do not send online users table
								 CLIENT_FLAGS_HIDEUSERS = 64   // do not send users table
};

//+------------------------------------------------------------------+
//|  Server datafeed description                                     |
//+------------------------------------------------------------------+
[Serializable]
public value class FeedDescription
{
public:
	int version;   // data source version
	String ^name;  // data source name
	String ^copyright;      // copyright string
	String ^web;  // data source web
	String ^email; // data source email
	String ^server; // feeder server
	String ^username;       // default feeder name
	String ^userpass;       // default feeder password
	int modes;    // feeder modes (enum FeederModes)
	String ^description;     // feeder description
	String ^module; // datafeed name in license
	
	FeedDescription(MetaQuotes::FeedDescription& Fee) {
		version = Fee.version;
		name = Marshal::PtrToStringAnsi(IntPtr(Fee.name));
		copyright = Marshal::PtrToStringAnsi(IntPtr(Fee.copyright));
		web = Marshal::PtrToStringAnsi(IntPtr(Fee.web));
		email = Marshal::PtrToStringAnsi(IntPtr(Fee.email));
		server = Marshal::PtrToStringAnsi(IntPtr(Fee.server));
		username = Marshal::PtrToStringAnsi(IntPtr(Fee.username));
		userpass = Marshal::PtrToStringAnsi(IntPtr(Fee.userpass));
		modes = Fee.modes;
		description = Marshal::PtrToStringAnsi(IntPtr(Fee.description));
		module = Marshal::PtrToStringAnsi(IntPtr(Fee.module));
	}

	FeedDescription(MetaQuotes::FeedDescription* Fee) {
		version = Fee->version;
		name = Marshal::PtrToStringAnsi(IntPtr(Fee->name));
		copyright = Marshal::PtrToStringAnsi(IntPtr(Fee->copyright));
		web = Marshal::PtrToStringAnsi(IntPtr(Fee->web));
		email = Marshal::PtrToStringAnsi(IntPtr(Fee->email));
		server = Marshal::PtrToStringAnsi(IntPtr(Fee->server));
		username = Marshal::PtrToStringAnsi(IntPtr(Fee->username));
		userpass = Marshal::PtrToStringAnsi(IntPtr(Fee->userpass));
		modes = Fee->modes;
		description = Marshal::PtrToStringAnsi(IntPtr(Fee->description));
		module = Marshal::PtrToStringAnsi(IntPtr(Fee->module));
	}

	void ToMT4(MetaQuotes::FeedDescription* Fee) {
		Fee->version = version;
		IntPtr temp_name;
		char* temp;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Fee->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		IntPtr temp_copyright;
		temp_copyright = Marshal::StringToHGlobalAnsi(copyright);
		temp = (char*)temp_copyright.ToPointer();
		if (temp != NULL)
		strcpy(Fee->copyright, (char *)(void *)temp_copyright);
		Marshal::FreeHGlobal(temp_copyright);
		IntPtr temp_web;
		temp_web = Marshal::StringToHGlobalAnsi(web);
		temp = (char*)temp_web.ToPointer();
		if (temp != NULL)
		strcpy(Fee->web, (char *)(void *)temp_web);
		Marshal::FreeHGlobal(temp_web);
		IntPtr temp_email;
		temp_email = Marshal::StringToHGlobalAnsi(email);
		temp = (char*)temp_email.ToPointer();
		if (temp != NULL)
		strcpy(Fee->email, (char *)(void *)temp_email);
		Marshal::FreeHGlobal(temp_email);
		IntPtr temp_server;
		temp_server = Marshal::StringToHGlobalAnsi(server);
		temp = (char*)temp_server.ToPointer();
		if (temp != NULL)
		strcpy(Fee->server, (char *)(void *)temp_server);
		Marshal::FreeHGlobal(temp_server);
		IntPtr temp_username;
		temp_username = Marshal::StringToHGlobalAnsi(username);
		temp = (char*)temp_username.ToPointer();
		if (temp != NULL)
		strcpy(Fee->username, (char *)(void *)temp_username);
		Marshal::FreeHGlobal(temp_username);
		IntPtr temp_userpass;
		temp_userpass = Marshal::StringToHGlobalAnsi(userpass);
		temp = (char*)temp_userpass.ToPointer();
		if (temp != NULL)
		strcpy(Fee->userpass, (char *)(void *)temp_userpass);
		Marshal::FreeHGlobal(temp_userpass);
		Fee->modes = modes;
		IntPtr temp_description;
		temp_description = Marshal::StringToHGlobalAnsi(description);
		temp = (char*)temp_description.ToPointer();
		if (temp != NULL)
		strcpy(Fee->description, (char *)(void *)temp_description);
		Marshal::FreeHGlobal(temp_description);
		IntPtr temp_module;
		temp_module = Marshal::StringToHGlobalAnsi(module);
		temp = (char*)temp_module.ToPointer();
		if (temp != NULL)
		strcpy(Fee->module, (char *)(void *)temp_module);
		Marshal::FreeHGlobal(temp_module);
	}

};


//--- feeder modes
public enum class FeederModes
{
	modeOnlyQuotes = 0, // only quotes feeder
	modeOnlyNews = 1, // only news feeder
	modeQuotesAndNews = 2, // quotes and news feeder
	modeQuotesOrNews = 3 // quotes or news feeder
};

//--- server datafeed
[Serializable]
public value class ServerFeed
{
public:


	String ^file;				// feeder file name
	FeedDescription^  feed;		// feeder description

	ServerFeed(MetaQuotes::ServerFeed& Ser) {
		file = Marshal::PtrToStringAnsi(IntPtr(Ser.file));
		feed = FeedDescription(Ser.feed);
	}

	ServerFeed(MetaQuotes::ServerFeed* Ser) {
		file = Marshal::PtrToStringAnsi(IntPtr(Ser->file));
		feed = FeedDescription(Ser->feed);
	}



	void ToMT4(MetaQuotes::ServerFeed* Ser) {
		IntPtr temp_file;
		char* temp;
		temp_file = Marshal::StringToHGlobalAnsi(file);
		temp = (char*)temp_file.ToPointer();
		if (temp != NULL)
		strcpy(Ser->file, (char *)(void *)temp_file);
		Marshal::FreeHGlobal(temp_file);
	}
};

//+------------------------------------------------------------------+
//|                           Charts                                 |
//+------------------------------------------------------------------+
//| Request chart history struct                                     |
//+------------------------------------------------------------------+
[Serializable]
public value class ChartInfo
{
public:
	String ^symbol;     // symbol
	int period;       // period (PERIOD_*)
	__time32_t start; // start of chart block
	__time32_t end;  // end of chart block
	__time32_t timesign;      // timestamp of existing chart base
	int mode; // request mode
	ChartInfo(MetaQuotes::ChartInfo& Cha) {
		symbol = Marshal::PtrToStringAnsi(IntPtr(Cha.symbol));
		period = Cha.period;
		start = Cha.start;
		end = Cha.end;
		timesign = Cha.timesign;
		mode = Cha.mode;
	}

	ChartInfo(MetaQuotes::ChartInfo* Cha) {
		symbol = Marshal::PtrToStringAnsi(IntPtr(Cha->symbol));
		period = Cha->period;
		start = Cha->start;
		end = Cha->end;
		timesign = Cha->timesign;
		mode = Cha->mode;
	}

	void ToMT4(MetaQuotes::ChartInfo* Cha) {
		IntPtr temp_symbol;
		char* temp;
		temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
		temp = (char*)temp_symbol.ToPointer();
		if (temp != NULL)
		strcpy(Cha->symbol, (char *)(void *)temp_symbol);
		Marshal::FreeHGlobal(temp_symbol);
		Cha->period = period;
		Cha->start = start;
		Cha->end = end;
		Cha->timesign = timesign;
		Cha->mode = mode;
	}

};
//--- chart period
public enum class ChartPeriod {
	PERIOD_M1 = 1, PERIOD_M5 = 5, PERIOD_M15 = 15, PERIOD_M30 = 30,
	PERIOD_H1 = 60, PERIOD_H4 = 240, PERIOD_D1 = 1440, PERIOD_W1 = 10080,
	PERIOD_MN1 = 43200
};
//--- request mode
public enum class RequestModes { CHART_RANGE_IN, CHART_RANGE_OUT, CHART_RANGE_LAST };

//+------------------------------------------------------------------+
//| Rate the in chart base                                           |
//+------------------------------------------------------------------+

[Serializable]
public value class RateInfo {
public:
	RateInfo(MetaQuotes::RateInfo &ri)
	{
		ctm = ri.ctm;
		open = ri.open;
		high = ri.high;
		low = ri.low;
		close = ri.close;
		vol = ri.vol;
	};

	RateInfo(MetaQuotes::RateInfo* ri)
	{
		ctm = ri->ctm;
		open = ri->open;
		high = ri->high;
		low = ri->low;
		close = ri->close;
		vol = ri->vol;
	};

	void ToMT4(MetaQuotes::RateInfo* Cha) {
		Cha->ctm = ctm;
		Cha->open = open;
		Cha->high = high;
		Cha->low = low;
		Cha->close = close;
		Cha->vol = vol;
	}

	__time32_t ctm;   // rate time
	int open;   // open price: 11987=119.87
	int high, low, close;    // high,low,close shift from open
	double      vol;   // volume

};

//+------------------------------------------------------------------+
//| Tick record in base                                              |
//+------------------------------------------------------------------+
[Serializable]
public value class TickRecord
{
public:
	__time32_t ctm;   // tick time
	double      bid, ask; // bid, ask
	int datafeed; // index if datafeed
	char       flags;  // TICK_FLAG_* flags

	TickRecord(MetaQuotes::TickRecord& Tic) {
		ctm = Tic.ctm;
		bid = Tic.bid;
		ask = Tic.ask;
		datafeed = Tic.datafeed;
	}

	TickRecord(MetaQuotes::TickRecord* Tic) {
		ctm = Tic->ctm;
		bid = Tic->bid;
		ask = Tic->ask;
		datafeed = Tic->datafeed;
	}


	void ToMT4(MetaQuotes::TickRecord* Tic) {
		Tic->ctm = ctm;
		Tic->bid = bid;
		Tic->ask = ask;
		Tic->datafeed = datafeed;
		Tic->flags = flags;
	}

};
[Flags]
public enum class TickFlags : int { TICK_FLAG_RAW = 1, TICK_FLAG_NORMAL = 2, TICK_FLAG_ALL = TICK_FLAG_RAW + TICK_FLAG_NORMAL };

//+------------------------------------------------------------------+
//| Tick request                                                     |
//+------------------------------------------------------------------+

[Serializable]
public value class TickRequest
{
public:
	String ^symbol;       // symbol
	__time32_t from;   // start of period
	__time32_t to;    // end of period
	int       flags;  // TICK_FLAG_* flags
	TickRequest(MetaQuotes::TickRequest& Tic) {
		symbol = Marshal::PtrToStringAnsi(IntPtr(Tic.symbol));
		from = Tic.from;
		to = Tic.to;
		flags = Tic.flags;
	}

	TickRequest(MetaQuotes::TickRequest* Tic) {
		symbol = Marshal::PtrToStringAnsi(IntPtr(Tic->symbol));
		from = Tic->from;
		to = Tic->to;
		flags = Tic->flags;
	}

	void ToMT4(MetaQuotes::TickRequest* Tic) {
		IntPtr temp_symbol;
		char* temp;
		temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
		temp = (char*)temp_symbol.ToPointer();
		if (temp != NULL)
		strcpy(Tic->symbol, (char *)(void *)temp_symbol);
		Marshal::FreeHGlobal(temp_symbol);
		Tic->from = from;
		Tic->to = to;
		Tic->flags = flags;
	}

};
//+------------------------------------------------------------------+
//| Performance information                                          |
//+------------------------------------------------------------------+

[Serializable]
public value class PerformanceInfo
{
public:
	__time32_t ctm;
	short users;  // online users
	short cpu;   // processor loading (%)
	int freemem; // free memory (Kb)
	int network; // network activity (Kb/s)
	int sockets; // all open sockets in system
	PerformanceInfo(MetaQuotes::PerformanceInfo& Per) {
		ctm = Per.ctm;
		users = Per.users;
		cpu = Per.cpu;
		freemem = Per.freemem;
		network = Per.network;
		sockets = Per.sockets;
	}

	PerformanceInfo(MetaQuotes::PerformanceInfo* Per) {
		ctm = Per->ctm;
		users = Per->users;
		cpu = Per->cpu;
		freemem = Per->freemem;
		network = Per->network;
		sockets = Per->sockets;
	}


	void ToMT4(MetaQuotes::PerformanceInfo* Per) {
		Per->ctm = ctm;
		Per->users = users;
		Per->cpu = cpu;
		Per->freemem = freemem;
		Per->network = network;
		Per->sockets = sockets;
	}
};

//+------------------------------------------------------------------+
//| Backup file information                                          |
//+------------------------------------------------------------------+
[Serializable]
public value class BackupInfo
{
public:
	String ^file;       // file name
	int size;   // file size
	__time32_t time;   // file time
	BackupInfo(MetaQuotes::BackupInfo& Bac) {
		file = Marshal::PtrToStringAnsi(IntPtr(Bac.file));
		size = Bac.size;
		time = Bac.time;
	}

	BackupInfo(MetaQuotes::BackupInfo* Bac) {
		file = Marshal::PtrToStringAnsi(IntPtr(Bac->file));
		size = Bac->size;
		time = Bac->time;
	}


	void ToMT4(MetaQuotes::BackupInfo* Bac) {
		IntPtr temp_file;
		char* temp;
		temp_file = Marshal::StringToHGlobalAnsi(file);
		temp = (char*)temp_file.ToPointer();
		if (temp != NULL)
		strcpy(Bac->file, (char *)(void *)temp_file);
		Marshal::FreeHGlobal(temp_file);
		Bac->size = size;
		Bac->time = time;
	}

};
//--- backup mode
public enum class BackupModes
{
	BACKUPS_ALL,       // all backup
	BACKUPS_PERIODICAL,   // periodical backups
	BACKUPS_STARTUP,     // backups on startup
	BACKUPS_DELETE      // backups on delete
};

//+------------------------------------------------------------------+
//|                        Databases                                 |
//+------------------------------------------------------------------+
//| Transaction types                                                |
//+------------------------------------------------------------------+
public enum class TransTypes {
	TRANS_ADD,
	TRANS_DELETE,
	TRANS_UPDATE,
	TRANS_CHANGE_GRP
};

//+------------------------------------------------------------------+
//| User Record                                                      |
//+------------------------------------------------------------------+

[Serializable]
public value class UserRecord {
public:

	UserRecord(MetaQuotes::UserRecord ur)
	{
		login = ur.login;
		group = Marshal::PtrToStringAnsi(IntPtr(ur.group));
		password = Marshal::PtrToStringAnsi(IntPtr(ur.password));

		enable = ur.enable;
		enable_change_password = enable_change_password;
		enable_read_only = ur.enable_read_only;
		enable_otp = ur.enable_otp;

		password_investor = Marshal::PtrToStringAnsi(IntPtr(ur.password_investor));
		password_phone = Marshal::PtrToStringAnsi(IntPtr(ur.password_phone));
		name = Marshal::PtrToStringAnsi(IntPtr(ur.name));
		country = Marshal::PtrToStringAnsi(IntPtr(ur.country));
		city = Marshal::PtrToStringAnsi(IntPtr(ur.city));
		state = Marshal::PtrToStringAnsi(IntPtr(ur.state));
		zipcode = Marshal::PtrToStringAnsi(IntPtr(ur.zipcode));
		address = Marshal::PtrToStringAnsi(IntPtr(ur.address));
		lead_source = Marshal::PtrToStringAnsi(IntPtr(ur.lead_source));
		phone = Marshal::PtrToStringAnsi(IntPtr(ur.phone));
		email = Marshal::PtrToStringAnsi(IntPtr(ur.email));
		comment = Marshal::PtrToStringAnsi(IntPtr(ur.comment));
		id = Marshal::PtrToStringAnsi(IntPtr(ur.id));
		status = Marshal::PtrToStringAnsi(IntPtr(ur.status));
		regdate = ur.regdate;
		lastdate = ur.lastdate;

		leverage = ur.leverage;
		agent_account = ur.agent_account;
		timestamp = ur.timestamp;

		balance = ur.balance;
		prevmonthbalance = ur.prevmonthbalance;
		prevbalance = ur.prevbalance;
		credit = ur.credit;
		interestrate = ur.interestrate;
		taxes = ur.taxes;
		prevmonthequity = ur.prevmonthequity;
		prevequity = ur.prevequity;

		otp_secret = Marshal::PtrToStringAnsi(IntPtr(ur.otp_secret));
		send_reports = ur.send_reports;
		mqid = ur.mqid;
		user_color = COLORREF(ur.user_color);

	}


	UserRecord(MetaQuotes::UserRecord* ur)
	{
		login = ur->login;
		group = Marshal::PtrToStringAnsi(IntPtr(ur->group));
		password = Marshal::PtrToStringAnsi(IntPtr(ur->password));

		enable = ur->enable;
		enable_change_password = enable_change_password;
		enable_read_only = ur->enable_read_only;
		enable_otp = ur->enable_otp;

		password_investor = Marshal::PtrToStringAnsi(IntPtr(ur->password_investor));
		password_phone = Marshal::PtrToStringAnsi(IntPtr(ur->password_phone));
		name = Marshal::PtrToStringAnsi(IntPtr(ur->name));
		country = Marshal::PtrToStringAnsi(IntPtr(ur->country));
		city = Marshal::PtrToStringAnsi(IntPtr(ur->city));
		state = Marshal::PtrToStringAnsi(IntPtr(ur->state));
		zipcode = Marshal::PtrToStringAnsi(IntPtr(ur->zipcode));
		address = Marshal::PtrToStringAnsi(IntPtr(ur->address));
		lead_source = Marshal::PtrToStringAnsi(IntPtr(ur->lead_source));
		phone = Marshal::PtrToStringAnsi(IntPtr(ur->phone));
		email = Marshal::PtrToStringAnsi(IntPtr(ur->email));
		comment = Marshal::PtrToStringAnsi(IntPtr(ur->comment));
		id = Marshal::PtrToStringAnsi(IntPtr(ur->id));
		status = Marshal::PtrToStringAnsi(IntPtr(ur->status));
		regdate = ur->regdate;
		lastdate = ur->lastdate;

		leverage = ur->leverage;
		agent_account = ur->agent_account;
		timestamp = ur->timestamp;

		balance = ur->balance;
		prevmonthbalance = ur->prevmonthbalance;
		prevbalance = ur->prevbalance;
		credit = ur->credit;
		interestrate = ur->interestrate;
		taxes = ur->taxes;
		prevmonthequity = ur->prevmonthequity;
		prevequity = ur->prevequity;

		otp_secret = Marshal::PtrToStringAnsi(IntPtr(ur->otp_secret));
		send_reports = ur->send_reports;
		mqid = ur->mqid;
		user_color = COLORREF(ur->user_color);
		

	}


	UserRecord(int log)
	{
		login = log;
	}

	void ToMT4(MetaQuotes::UserRecord* ur)
	{
		ur->login = login;

		char* temp;
		IntPtr temp_field;

		temp_field = Marshal::StringToHGlobalAnsi(group);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
			strcpy(ur->group, (char *)(void *)temp_field);
		
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(password);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->password, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		ur->enable = enable;
		ur->enable_change_password = enable_change_password;
		ur->enable_read_only = enable_read_only;
		ur->enable_otp = enable_otp;

		temp_field = Marshal::StringToHGlobalAnsi(password_investor);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->password_investor, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(password_phone);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->password_phone, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->name, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(country);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->country, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(city);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->city, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(state);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->state, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(zipcode);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->zipcode, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(address);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->address, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(lead_source);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->lead_source, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(phone);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->phone, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(email);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->email, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(comment);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->comment, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(id);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->id, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		temp_field = Marshal::StringToHGlobalAnsi(status);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->status, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		ur->regdate = regdate;
		ur->lastdate = lastdate;

		ur->leverage = leverage;
		ur->agent_account = agent_account;
		ur->timestamp = timestamp;

		ur->balance = balance;
		ur->prevmonthbalance = prevmonthbalance;
		ur->prevbalance = prevbalance;
		ur->credit = credit;
		ur->interestrate = interestrate;
		ur->taxes = taxes;
		ur->prevmonthequity = prevmonthequity;
		ur->prevequity = prevequity;


		temp_field = Marshal::StringToHGlobalAnsi(otp_secret);
		temp = (char*)temp_field.ToPointer();
		if (temp != NULL)
		strcpy(ur->otp_secret, (char *)(void *)temp_field);
		Marshal::FreeHGlobal(temp_field);

		ur->send_reports = send_reports;
		ur->mqid = mqid;
		ur->user_color = TO_COLORREF(user_color);
		

	}

	// common settings
	int login;  // login
	String  ^group;  // group
	String  ^password; // password
					   // access flags
	int enable;  // enable
	int enable_change_password; // allow to change password
	int enable_read_only;    // allow to open/positions (TRUE-may not trade)
	int enable_otp;  // allow to use one-time password
							 //
	String  ^password_investor;    // read-only mode password
	String  ^password_phone;     // phone password
	String  ^name;   // name
	String  ^country;  // country
	String  ^city;   // city
	String  ^state;   // state
	String  ^zipcode;  // zipcode
	String  ^address;  // address
	String  ^lead_source;       // lead source
	String  ^phone;   // phone
	String  ^email;   // email
	String  ^comment;  // comment
	String  ^id;    // SSN (IRD)
	String  ^status;  // status
	__time32_t  regdate;  // registration date
	__time32_t  lastdate; // last coonection time
						  // trade settings
	int leverage; // leverage
	int agent_account;      // agent account
	__time32_t  timestamp;
	int reserved; // for future use
				  // trade data
	double balance;  // balance
	double prevmonthbalance;    // previous month balance
	double prevbalance;       // previous day balance
	double credit;  // credit
	double interestrate;      // accumulated interest rate
	double taxes;   // taxes
	double prevmonthequity;      // previous month equity
	double prevequity;  // previous day equity

						//
	String  ^otp_secret; // public key
	int send_reports;      // enable send reports by email
	unsigned int mqid; // internal use
	COLORREF user_color;       // color got to client (used by MT Manager)
							//
	String  ^unused;  // for future use
	String  ^api_data; // for API usage
};

//+------------------------------------------------------------------+
//| Users group operation                                            |
//+------------------------------------------------------------------+

[Serializable]
public value class GroupCommandInfo
{
public:
	int len;       // length of users list
	char       command;     // group coommand
	String ^newgroup;   // new group
	int leverage;     // new leverage

	GroupCommandInfo(MetaQuotes::GroupCommandInfo& Gro) {
		len = Gro.len;
		newgroup = Marshal::PtrToStringAnsi(IntPtr(Gro.newgroup));
		leverage = Gro.leverage;
	}

	GroupCommandInfo(MetaQuotes::GroupCommandInfo* Gro) {
		len = Gro->len;
		newgroup = Marshal::PtrToStringAnsi(IntPtr(Gro->newgroup));
		leverage = Gro->leverage;
	}

	void ToMT4(MetaQuotes::GroupCommandInfo* Gro) {
		Gro->len = len;
		Gro->command = command;
		IntPtr temp_newgroup;
		char* temp;
		temp_newgroup = Marshal::StringToHGlobalAnsi(newgroup);
		temp = (char*)temp_newgroup.ToPointer();
		if (temp != NULL)
		strcpy(Gro->newgroup, (char *)(void *)temp_newgroup);
		Marshal::FreeHGlobal(temp_newgroup);
		Gro->leverage = leverage;
	}

};

//--- group commands
public enum class GroupCommands { GROUP_DELETE, GROUP_ENABLE, GROUP_DISABLE, GROUP_LEVERAGE, GROUP_SETGROUP };


//+------------------------------------------------------------------+
//| Online user description                                          |
//+------------------------------------------------------------------+
[Serializable]
public value class OnlineRecord
{
public:
	int counter;    // connections counter
	int reserved;   // reserved
	int login;     // user login
	unsigned int      ip;      // connection ip address
	String ^group;   // user group
	OnlineRecord(MetaQuotes::OnlineRecord& Onl) {
		counter = Onl.counter;
		reserved = Onl.reserved;
		login = Onl.login;
		ip = Onl.ip;
		group = Marshal::PtrToStringAnsi(IntPtr(Onl.group));
	}

	OnlineRecord(MetaQuotes::OnlineRecord* Onl) {
		counter = Onl->counter;
		reserved = Onl->reserved;
		login = Onl->login;
		ip = Onl->ip;
		group = Marshal::PtrToStringAnsi(IntPtr(Onl->group));
	}

	void ToMT4(MetaQuotes::OnlineRecord* Onl) {
		Onl->counter = counter;
		Onl->reserved = reserved;
		Onl->login = login;
		Onl->ip = ip;
		IntPtr temp_group;
		char* temp;
		temp_group = Marshal::StringToHGlobalAnsi(group);
		temp = (char*)temp_group.ToPointer();
		if (temp != NULL)
		strcpy(Onl->group, (char *)(void *)temp_group);
		Marshal::FreeHGlobal(temp_group);
	}

};

//+------------------------------------------------------------------+
//| Trade Record                                                     |
//+------------------------------------------------------------------+
[Serializable]
public value class TradeRecord {
public:

	TradeRecord(MetaQuotes::TradeRecord &tr)
	{
		order = tr.order;
		login = tr.login;
		symbol = Marshal::PtrToStringAnsi(IntPtr(tr.symbol));
		digits = tr.digits;
		cmd = tr.cmd;
		volume = tr.volume;

		open_time = tr.open_time;
		state = tr.state;
		open_price = tr.open_price;
		sl = tr.sl;
		tp = tr.tp;
		close_time = tr.close_time;
		gw_volume = tr.gw_volume;
		expiration = tr.expiration;
		//conv_reserv = tr.conv_reserv;
		conv_rate1 = tr.conv_rates[0];
		conv_rate2 = tr.conv_rates[1];

		commission = tr.commission;
		commission_agent = tr.commission_agent;
		storage = tr.storage;
		close_price = tr.close_price;
		profit = tr.profit;
		taxes = tr.taxes;
		magic = tr.magic;
		comment = Marshal::PtrToStringAnsi(IntPtr(tr.comment));
		gw_order = tr.gw_order;
		activation = tr.activation;
		gw_open_price = tr.gw_open_price;
		gw_close_price = tr.gw_close_price;
		margin_rate = tr.margin_rate;// spread
		timestamp = tr.timestamp; // timestamp
	}
	TradeRecord(MetaQuotes::TradeRecord *tr)
	{
		order = tr->order;
		login = tr->login;
		symbol = Marshal::PtrToStringAnsi(IntPtr(tr->symbol));
		digits = tr->digits;
		cmd = tr->cmd;
		volume = tr->volume;

		open_time = tr->open_time;
		state = tr->state;
		open_price = tr->open_price;
		sl = tr->sl;
		tp = tr->tp;
		close_time = tr->close_time;
		gw_volume = tr->gw_volume;
		expiration = tr->expiration;
		//conv_reserv = tr->conv_reserv;
		conv_rate1 = tr->conv_rates[0];
		conv_rate2 = tr->conv_rates[1];

		commission = tr->commission;
		commission_agent = tr->commission_agent;
		storage = tr->storage;
		close_price = tr->close_price;
		profit = tr->profit;
		taxes = tr->taxes;
		magic = tr->magic;
		comment = Marshal::PtrToStringAnsi(IntPtr(tr->comment));
		gw_order = tr->gw_order;
		activation = tr->activation;
		gw_open_price = tr->gw_open_price;
		gw_close_price = tr->gw_close_price;
		margin_rate = tr->margin_rate;// spread
		timestamp = tr->timestamp; // timestamp
	}
	TradeRecord(int ticket)
	{
		order = ticket;
	}

	void ToMT4(MetaQuotes::TradeRecord* tr)
	{
		tr->order = order;
		tr->login = login;
		IntPtr temp_symbol;
		char* temp;
		temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
		temp = (char*)temp_symbol.ToPointer();
		if (temp != NULL)
		strcpy(tr->symbol, (char *)(void *)temp_symbol);
		Marshal::FreeHGlobal(temp_symbol);
		tr->digits = digits;
		tr->cmd = cmd;
		tr->volume = volume;

		tr->open_time = open_time;
		tr->state = state;
		tr->open_price = open_price;
		tr->sl = sl;
		tr->tp = tp;
		tr->close_time = close_time;
		tr->gw_volume = gw_volume;
		tr->expiration = expiration;
		//conv_reserv = conv_reserv;
		tr->conv_rates[0] = conv_rate1;
		tr->conv_rates[1] = conv_rate2;

		tr->commission = commission;
		tr->commission_agent = commission_agent;
		tr->storage = storage;
		tr->close_price = close_price;
		tr->profit = profit;
		tr->taxes = taxes;
		tr->magic = magic;
		IntPtr temp_comment;
		temp_symbol = Marshal::StringToHGlobalAnsi(comment);
		temp = (char*)temp_symbol.ToPointer();
		if (temp != NULL)
		strcpy(tr->comment, (char *)(void *)temp_comment);
		Marshal::FreeHGlobal(temp_symbol);


		tr->gw_order = gw_order;
		tr->activation = activation;
		tr->gw_open_price = gw_open_price;
		tr->gw_close_price = gw_close_price;
		tr->margin_rate = margin_rate;// spread
		tr->timestamp = timestamp; // timestamp
	}


	int order;      // order ticket
	int login;      // owner's login
	String ^symbol;      // security
	int digits;      // security precision
	int  cmd;       // trade command
	int volume;      // volume
					 //----
	__time32_t open_time;    // open time
	int state;      // reserved
	double      open_price;    // open price
	double      sl, tp;      // stop loss & take profit
	__time32_t close_time;   // close time
	int gw_volume;    // gateway order volume
	__time32_t expiration;   // pending order's expiration time
	int conv_reserv;   // reserved
	double      conv_rate1;    // convertation rates from profit currency to group deposit currency
	double      conv_rate2;    // convertation rates from profit currency to group deposit currency
							   // (first element-for open time, second element-for close time)
	double      commission;    // commission
	double      commission_agent; // agent commission
	double      storage;     // order swaps
	double      close_price;   // close price
	double      profit;      // profit
	double      taxes;      // taxes
	int magic;      // special value used by client experts
	String ^comment;     // comment
	int gw_order;     // gateway order ticket
	int activation;    // used by MT Manager
	short gw_open_price;  // gateway order price deviation (pips) from order open price
	short gw_close_price;  // gateway order price deviation (pips) from order close price
	double      margin_rate;   // margin convertation rate (rate of convertation from margin currency to deposit one)

	int spread;      // spread
	int timestamp;    // timestamp

};


//--- trade commands
public enum class OrderCommands { OP_BUY = 0, OP_SELL, OP_BUY_LIMIT, OP_SELL_LIMIT, OP_BUY_STOP, OP_SELL_STOP, OP_BALANCE, OP_CREDIT };
//--- trade record state
public enum class TradeRecordState { TS_OPEN_NORMAL, TS_OPEN_REMAND, TS_OPEN_RESTORED, TS_CLOSED_NORMAL, TS_CLOSED_PART, TS_CLOSED_BY, TS_DELETED };
//--- trade record reasons
public enum class TradeRecordReasons
{
	TR_REASON_CLIENT = 0, // client terminal
	TR_REASON_EXPERT = 1, // expert
	TR_REASON_DEALER = 2, // dealer
	TR_REASON_SIGNAL = 3, // signal
	TR_REASON_GATEWAY = 4, // gateway
	TR_REASON_MOBILE = 5, // mobile terminal
	TR_REASON_WEB = 6, // Web terminal
	TR_REASON_API = 7, // API
};
//--- activation types
//--- *_ROLLBACK=current price roll back from activation price level
public enum class ActivationStates
{
	//--- no activation
	ACTIVATION_NONE = 0,
	//--- stoploss, takeprofit, pendings
	ACTIVATION_SL, ACTIVATION_TP, ACTIVATION_PENDING,
	//--- stopout
	ACTIVATION_STOPOUT,
	//--- rollbacks
	ACTIVATION_SL_ROLLBACK = -ACTIVATION_SL,
	ACTIVATION_TP_ROLLBACK = -ACTIVATION_TP,
	ACTIVATION_PENDING_ROLLBACK = -ACTIVATION_PENDING,
	ACTIVATION_STOPOUT_ROLLBACK = -ACTIVATION_STOPOUT
};
//+------------------------------------------------------------------+
//| TradeRecord restoring from backup result                         |
//+------------------------------------------------------------------+

[Serializable]
public value class TradeRestoreResult
{
public:
	int order;      // order
	UCHAR       res;       // RET_OK  - order restored
						   // RET_ERROR - error restoring order
	TradeRestoreResult(MetaQuotes::TradeRestoreResult& Tra) {
		order = Tra.order;
		res = Tra.res;
	}

	TradeRestoreResult(MetaQuotes::TradeRestoreResult* Tra) {
		order = Tra->order;
		res = Tra->res;
	}

	void ToMT4(MetaQuotes::TradeRestoreResult* Tra) {
		Tra->order = order;
		Tra->res = res;
	}

};
//+------------------------------------------------------------------+
//| Trade transaction                                                |
//+------------------------------------------------------------------+
//--- trade transaction types
public enum class TradeTransactionTypes {
			//---
			TT_PRICES_GET,                      // prices requets
			TT_PRICES_REQUOTE,                  // requote
			//--- client trade transaction
			TT_ORDER_IE_OPEN = 64,              // open order (Instant Execution)
			TT_ORDER_REQ_OPEN,                  // open order (Request Execution)
			TT_ORDER_MK_OPEN,                   // open order (Market Execution)
			TT_ORDER_PENDING_OPEN,              // open pending order
			//---
			TT_ORDER_IE_CLOSE,                  // close order (Instant Execution)
			TT_ORDER_REQ_CLOSE,                 // close order (Request Execution)
			TT_ORDER_MK_CLOSE,                  // close order (Market Execution)
			//---
			TT_ORDER_MODIFY,                    // modify pending order
			TT_ORDER_DELETE,                    // delete pending order
			TT_ORDER_CLOSE_BY,                  // close order by order
			TT_ORDER_CLOSE_ALL,                 // close all orders by symbol
			//--- broker trade transactions
			TT_BR_ORDER_OPEN,                   // open order
			TT_BR_ORDER_CLOSE,                  // close order
			TT_BR_ORDER_DELETE,                 // delete order (ANY OPEN ORDER!!!)
			TT_BR_ORDER_CLOSE_BY,               // close order by order
			TT_BR_ORDER_CLOSE_ALL,              // close all orders by symbol
			TT_BR_ORDER_MODIFY,                 // modify open price, stoploss, takeprofit etc. of order
			TT_BR_ORDER_ACTIVATE,               // activate pending order
			TT_BR_ORDER_COMMENT,                // modify comment of order
			TT_BR_BALANCE                       // balance/credit
		};
[Serializable]
public value class TradeTransInfo {
public:

	TradeTransInfo(MetaQuotes::TradeTransInfo *tti)
	{
		IntPtr temp;

		type = (TradeTransactionTypes)tti->type;
		cmd = tti->cmd;
		order = tti->order;
		orderby = tti->orderby;
		expiration = tti->expiration;
		symbol = Marshal::PtrToStringAnsi(IntPtr(tti->symbol));
		comment = Marshal::PtrToStringAnsi(IntPtr(tti->comment));
		volume = tti->volume;
		price = tti->price;
		sl = tti->sl;
		tp = tti->tp;
	}

	TradeTransInfo(MetaQuotes::TradeTransInfo tti)
	{
		IntPtr temp;

		type = (TradeTransactionTypes)tti.type;
		cmd = tti.cmd;
		order = tti.order;
		orderby = tti.orderby;
		expiration = tti.expiration;
		symbol = Marshal::PtrToStringAnsi(IntPtr(tti.symbol));
		comment = Marshal::PtrToStringAnsi(IntPtr(tti.comment));
		volume = tti.volume;
		price = tti.price;
		sl = tti.sl;
		tp = tti.tp;
	}

	void ToMT4(MetaQuotes::TradeTransInfo *tti)
	{
		IntPtr temp;

		tti->type = (UCHAR)type;
		tti->cmd = (short)cmd;
		tti->order = order;
		tti->orderby = orderby;
		tti->expiration = expiration;
		char* tempChar;
		temp = Marshal::StringToHGlobalAnsi(symbol);
		tempChar = (char*)temp.ToPointer();
		if (tempChar != NULL)
		strcpy(tti->symbol, (char *)(void *)temp);
		Marshal::FreeHGlobal(temp);

		temp = Marshal::StringToHGlobalAnsi(comment);
		tempChar = (char*)temp.ToPointer();
		if (tempChar != NULL)
		strcpy(tti->comment, (char *)(void *)temp);
		Marshal::FreeHGlobal(temp);

		tti->volume = volume;
		tti->price = price;
		tti->sl = sl;
		tti->tp = tp;
	}

	TradeTransactionTypes type;      // trade transaction type
	int     cmd;      // trade command
	int  order, orderby; // order, order by
	String ^symbol;     // trade symbol
	int  volume;     // trade volume
	double  price;     // trade price
	double  sl, tp;     // stoploss, takeprofit
	int  ie_deviation;  // deviation on IE
	String ^comment;    // comment
	__time32_t expiration;   // pending order expiration time
	int  crc;      // crc
};



//--- trade request flags
public enum class EnReqFlags
{
	TT_FLAG_NONE = 0x00000000,     // flags none
	TT_FLAG_SIGNAL = 0x00000001,     // placed by signal
	TT_FLAG_EXPERT = 0x00000002,     // placed by expert
	TT_FLAG_GATEWAY = 0x00000004,     // placed by gateway
	TT_FLAG_MOBILE = 0x00000008,     // placed by mobile terminal
	TT_FLAG_WEB = 0x00000010,     // placed by web terminal
	TT_FLAG_API = 0x00000020,     // placed by api
};

//+------------------------------------------------------------------+
//| Margin level of the user                                         |
//+------------------------------------------------------------------+
[Serializable]
public value class MarginLevel
{
public:

MarginLevel(MetaQuotes::MarginLevel &ml)
{
	login = ml.login;
	group = Marshal::PtrToStringAnsi(IntPtr(ml.group));
	leverage = ml.leverage;
	updated = ml.updated;
	balance = ml.balance;
	equity = ml.equity;
	volume = ml.volume;
	margin = ml.margin;
	margin_free = ml.margin_free;
	margin_level = ml.margin_level;
	margin_type = ml.margin_type;
	level_type = ml.level_type;
}

MarginLevel(MetaQuotes::MarginLevel* ml)
{
	login = ml->login;
	group = Marshal::PtrToStringAnsi(IntPtr(ml->group));
	leverage = ml->leverage;
	updated = ml->updated;
	balance = ml->balance;
	equity = ml->equity;
	volume = ml->volume;
	margin = ml->margin;
	margin_free = ml->margin_free;
	margin_level = ml->margin_level;
	margin_type = ml->margin_type;
	level_type = ml->level_type;
}

void ToMT4(MetaQuotes::MarginLevel* Mar) {
	Mar->login = login;
	IntPtr temp_group;
	char* temp;
	temp_group = Marshal::StringToHGlobalAnsi(group);
	temp = (char*)temp_group.ToPointer();
	if (temp != NULL)
	strcpy(Mar->group, (char *)(void *)temp_group);
	Marshal::FreeHGlobal(temp_group);
	Mar->leverage = leverage;
	Mar->updated = updated;
	Mar->balance = balance;
	Mar->equity = equity;
	Mar->volume = volume;
	Mar->margin = margin;
	Mar->margin_free = margin_free;
	Mar->margin_level = margin_level;
	Mar->margin_type = margin_type;
	Mar->level_type = level_type;
}

int login;// user login
String^       group;// user group
int leverage;// user leverage
int updated;// (internal)
double balance;// balance+credit
double equity;// equity
int volume;// lots
double margin;// margin requirements
double margin_free;// free margin
double margin_level;// margin level
int margin_type;// margin controlling type (percent/currency)
int level_type;// level type(ok/margincall/stopout)
};

//--- margin level type
public enum class MarginLevelTypes {
	MARGINLEVEL_OK = 0,
	MARGINLEVEL_MARGINCALL,
	MARGINLEVEL_STOPOUT
};

//+------------------------------------------------------------------+
//| Trade request                                                    |
//+------------------------------------------------------------------+
[Serializable]
public value class RequestInfo
{
public:
	//--- general props
	int id;  // request id
	char       status;       // request status
	DWORD       time; // request time
	int manager;       // manager processing request (if any)
					   //--- user info
	int login; // user login
	String ^group;      // user group
	double      balance;       // user balance
	double      credit;       // user credit
							  //--- processing trade transaction
	List<double>^   prices;      // bid/ask
	TradeTransInfo  trade; // trade transaction
	int gw_volume;      // gateway order volume
	int gw_order;      // gateway order ticket
	short gw_price;      // gateway order price deviation (pips) from request price

	RequestInfo(MetaQuotes::RequestInfo& Req) {
		id = Req.id;
		status = Req.status;
		manager = Req.manager;
		login = Req.login;
		group = Marshal::PtrToStringAnsi(IntPtr(Req.group));
		balance = Req.balance;
		credit = Req.credit;
		gw_volume = Req.gw_volume;
		gw_order = Req.gw_order;
		gw_price = Req.gw_price;
		trade = TradeTransInfo(Req.trade);
		prices = gcnew System::Collections::Generic::List<double>();
		for (int i = 0; i < 2; i++)
			prices->Add(Req.prices[i]);
	}

	RequestInfo(MetaQuotes::RequestInfo* Req) {
		id = Req->id;
		status = Req->status;
		manager = Req->manager;
		login = Req->login;
		group = Marshal::PtrToStringAnsi(IntPtr(Req->group));
		balance = Req->balance;
		credit = Req->credit;
		gw_volume = Req->gw_volume;
		gw_order = Req->gw_order;
		gw_price = Req->gw_price;
		trade = TradeTransInfo(Req->trade);
		for (int i = 0; i < 2; i++)
			prices->Add(Req->prices[i]);
	}

	void ToMT4(MetaQuotes::RequestInfo* Req) {
		Req->id = id;
		Req->status = status;
		Req->time = time;
		Req->manager = manager;
		Req->login = login;
		IntPtr temp_group;
		char* temp;
		temp_group = Marshal::StringToHGlobalAnsi(group);
		temp = (char*)temp_group.ToPointer();
		if (temp != NULL)
		strcpy(Req->group, (char *)(void *)temp_group);
		Marshal::FreeHGlobal(temp_group);
		Req->balance = balance;
		Req->credit = credit;
		for (int i = 0; i < 2; i++) {
			Req->prices[i] = prices[i];
		}
		Req->gw_volume = gw_volume;
		Req->gw_order = gw_order;
		Req->gw_price = gw_price;
		trade.ToMT4(&Req->trade);
	}

};

//--- trade request status
public enum class tradeRequestStatus { DC_EMPTY, DC_REQUEST, DC_LOCKED, DC_ANSWERED, DC_RESETED, DC_CANCELED };
//--- request confirmation modes
public enum class EnConfirmModes
{
	CONFIRM_MODE_ADD_PRICES = 0x00000001,  // throw in prices
	CONFIRM_MODE_PACKET = 0x00000002   // multiple execution
};
//+------------------------------------------------------------------+
//| Daily report                                                     |
//+------------------------------------------------------------------+
[Serializable]
public value class DailyReport
{
public:
	int login; // login
	__time32_t ctm;  // time
	String ^group;      // group
	String ^bank;       // bank
	double      balance_prev;     // previous balance
	double      balance;       // balance
	double      deposit;       // deposit
	double      credit; // credit
	double      profit_closed;    // closed profit/loss
	double      profit; // floating profit/loss
	double      equity; // equity
	double      margin; // used margin
	double      margin_free;     // free margin
								 //---
	int next;  // (internal)

	DailyReport(MetaQuotes::DailyReport& Dai) {
		login = Dai.login;
		ctm = Dai.ctm;
		group = Marshal::PtrToStringAnsi(IntPtr(Dai.group));
		bank = Marshal::PtrToStringAnsi(IntPtr(Dai.bank));
		balance_prev = Dai.balance_prev;
		balance = Dai.balance;
		deposit = Dai.deposit;
		credit = Dai.credit;
		profit_closed = Dai.profit_closed;
		profit = Dai.profit;
		equity = Dai.equity;
		margin = Dai.margin;
		margin_free = Dai.margin_free;
		next = Dai.next;
	}

	DailyReport(MetaQuotes::DailyReport* Dai) {
		login = Dai->login;
		ctm = Dai->ctm;
		group = Marshal::PtrToStringAnsi(IntPtr(Dai->group));
		bank = Marshal::PtrToStringAnsi(IntPtr(Dai->bank));
		balance_prev = Dai->balance_prev;
		balance = Dai->balance;
		deposit = Dai->deposit;
		credit = Dai->credit;
		profit_closed = Dai->profit_closed;
		profit = Dai->profit;
		equity = Dai->equity;
		margin = Dai->margin;
		margin_free = Dai->margin_free;
		next = Dai->next;
	}

	void ToMT4(MetaQuotes::DailyReport* Dai) {
		Dai->login = login;
		Dai->ctm = ctm;
		IntPtr temp_group;
		char* temp;
		temp_group = Marshal::StringToHGlobalAnsi(group);
		temp = (char*)temp_group.ToPointer();
		if (temp != NULL)
		strcpy(Dai->group, (char *)(void *)temp_group);
		Marshal::FreeHGlobal(temp_group);
		IntPtr temp_bank;
		temp_bank = Marshal::StringToHGlobalAnsi(bank);
		temp = (char*)temp_bank.ToPointer();
		if (temp != NULL)
		strcpy(Dai->bank, (char *)(void *)temp_bank);
		Marshal::FreeHGlobal(temp_bank);
		Dai->balance_prev = balance_prev;
		Dai->balance = balance;
		Dai->deposit = deposit;
		Dai->credit = credit;
		Dai->profit_closed = profit_closed;
		Dai->profit = profit;
		Dai->equity = equity;
		Dai->margin = margin;
		Dai->margin_free = margin_free;
		Dai->next = next;
	}
};
//+------------------------------------------------------------------+
//| Reports request                                                  |
//+------------------------------------------------------------------+

[Serializable]
public value class ReportGroupRequest
{
public:
	String ^name;      // request group name
	__time32_t from; // from
	__time32_t to;  // to
	int total; // total logins in request group
	ReportGroupRequest(MetaQuotes::ReportGroupRequest& Rep) {
		name = Marshal::PtrToStringAnsi(IntPtr(Rep.name));
		from = Rep.from;
		to = Rep.to;
		total = Rep.total;
	}

	ReportGroupRequest(MetaQuotes::ReportGroupRequest* Rep) {
		name = Marshal::PtrToStringAnsi(IntPtr(Rep->name));
		from = Rep->from;
		to = Rep->to;
		total = Rep->total;
	}


	void ToMT4(MetaQuotes::ReportGroupRequest* Rep) {
		IntPtr temp_name;
		char* temp;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Rep->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		Rep->from = from;
		Rep->to = to;
		Rep->total = total;
	}
};

//+------------------------------------------------------------------+
//| Daily reports request                                            |
//+------------------------------------------------------------------+
[Serializable]
public value class DailyGroupRequest
{
public:
	String ^name;      // group name
	__time32_t from; // from
	__time32_t to;  // to
	int total; // total logins in request group
	int reserved;      // reserved
	DailyGroupRequest(MetaQuotes::DailyGroupRequest& Dai) {
		name = Marshal::PtrToStringAnsi(IntPtr(Dai.name));
		from = Dai.from;
		to = Dai.to;
		total = Dai.total;
		reserved = Dai.reserved;
	}

	DailyGroupRequest(MetaQuotes::DailyGroupRequest* Dai) {
		name = Marshal::PtrToStringAnsi(IntPtr(Dai->name));
		from = Dai->from;
		to = Dai->to;
		total = Dai->total;
		reserved = Dai->reserved;
	}

	void ToMT4(MetaQuotes::DailyGroupRequest* Dai) {
		IntPtr temp_name;
		char* temp;
		temp_name = Marshal::StringToHGlobalAnsi(name);
		temp = (char*)temp_name.ToPointer();
		if (temp != NULL)
		strcpy(Dai->name, (char *)(void *)temp_name);
		Marshal::FreeHGlobal(temp_name);
		Dai->from = from;
		Dai->to = to;
		Dai->total = total;
		Dai->reserved = reserved;
	}
};
//+------------------------------------------------------------------+
//| Selected symbol information                                      |
//+------------------------------------------------------------------+
[Serializable]
public value class SymbolInfo
{
public:
SymbolInfo(MetaQuotes::SymbolInfo& si)
{
	symbol = Marshal::PtrToStringAnsi(IntPtr(si.symbol));
	digits = si.digits;
	count = si.count;
	visible = si.visible;
	type = si.type;
	point = si.point;
	spread = si.spread;
	spread_balance = si.spread_balance;
	direction = si.direction;
	updateflag = si.updateflag;
	lasttime = si.lasttime;
	bid = si.bid;
	ask = si.ask;
	high = si.high;
	low = si.low;
	commission = si.commission;
	comm_type = si.comm_type;

}


SymbolInfo(MetaQuotes::SymbolInfo* si)
{
	symbol = Marshal::PtrToStringAnsi(IntPtr(si->symbol));
	digits = si->digits;
	count = si->count;
	visible = si->visible;
	type = si->type;
	point = si->point;
	spread = si->spread;
	spread_balance = si->spread_balance;
	direction = si->direction;
	updateflag = si->updateflag;
	lasttime = si->lasttime;
	bid = si->bid;
	ask = si->ask;
	high = si->high;
	low = si->low;
	commission = si->commission;
	comm_type = si->comm_type;

}

void ToMT4(MetaQuotes::SymbolInfo* Sym) {
	IntPtr temp_symbol;
	char* temp;
	temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
	temp = (char*)temp_symbol.ToPointer();
	if (temp != NULL)
	strcpy(Sym->symbol, (char *)(void *)temp_symbol);
	Marshal::FreeHGlobal(temp_symbol);
	Sym->digits = digits;
	Sym->count = count;
	Sym->visible = visible;
	Sym->type = type;
	Sym->point = point;
	Sym->spread = spread;
	Sym->spread_balance = spread_balance;
	Sym->direction = direction;
	Sym->updateflag = updateflag;
	Sym->lasttime = lasttime;
	Sym->bid = bid;
	Sym->ask = ask;
	Sym->high = high;
	Sym->low = low;
	Sym->commission = commission;
	Sym->comm_type = comm_type;
}

String ^symbol;      // symbol name
int digits; // floating point digits
int count;  // symbol counter
int visible; // visibility
			 //---
int type;  // symbol type (symbols group index)
double      point;  // symbol point=1/pow(10,digits)
int spread; // symbol spread
int spread_balance;    // spread balance
//---
int direction;       // direction
int updateflag;      // update flag
__time32_t lasttime;       // last tick time
double      bid, ask; // bid, ask
double      high, low;       // high, low
double      commission;      // commission
int comm_type;       // commission type
};
//--- symbol price direction
public enum class SymbolPriceDirection { SDIR_UP, SDIR_DOWN, SDIR_NONE };
//+------------------------------------------------------------------+
//| Symbol summary                                                   |
//+------------------------------------------------------------------+
[Serializable]
public value class SymbolSummary
{
public:
SymbolSummary(MetaQuotes::SymbolSummary& ss)
{
	symbol = Marshal::PtrToStringAnsi(IntPtr(ss.symbol));
	count = ss.count;
	digits = ss.digits;
	type = ss.type;
	orders = ss.orders;
	buylots = ss.buylots;
	selllots = ss.selllots;
	buyprice = ss.buyprice;
	sellprice = ss.sellprice;
	profit = ss.profit;
	covorders = ss.covorders;
	covbuylots = ss.covbuylots;
	covselllots = ss.covselllots;
	covbuyprice = ss.covbuyprice;
	covsellprice = ss.covsellprice;
	covprofit = ss.covprofit;
}
SymbolSummary(MetaQuotes::SymbolSummary* ss)
{
	symbol = Marshal::PtrToStringAnsi(IntPtr(ss->symbol));
	count = ss->count;
	digits = ss->digits;
	type = ss->type;
	orders = ss->orders;
	buylots = ss->buylots;
	selllots = ss->selllots;
	buyprice = ss->buyprice;
	sellprice = ss->sellprice;
	profit = ss->profit;
	covorders = ss->covorders;
	covbuylots = ss->covbuylots;
	covselllots = ss->covselllots;
	covbuyprice = ss->covbuyprice;
	covsellprice = ss->covsellprice;
	covprofit = ss->covprofit;
}

void ToMT4(MetaQuotes::SymbolSummary* Sym) {
	IntPtr temp_symbol;
	char* temp;
	temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
	temp = (char*)temp_symbol.ToPointer();
	if (temp != NULL)
	strcpy(Sym->symbol, (char *)(void *)temp_symbol);
	Marshal::FreeHGlobal(temp_symbol);
	Sym->count = count;
	Sym->digits = digits;
	Sym->type = type;
	Sym->orders = orders;
	Sym->buyprice = buyprice;
	Sym->sellprice = sellprice;
	Sym->profit = profit;
	Sym->covorders = covorders;
	Sym->covbuyprice = covbuyprice;
	Sym->covsellprice = covsellprice;
	Sym->covprofit = covprofit;
}

String ^symbol;     // symbol
int count; // symbol counter
int digits;       // floating point digits
int type; // symbol type (symbol group index)
//--- clients summary
int orders;       // number of client orders
__int64      buylots;       // buy volume
__int64      selllots;      // sell volume
double      buyprice;      // average buy price
double      sellprice;      // average sell price
double      profit;       // clients profit
//--- coverage summary
int covorders;      // number of coverage orders
__int64      covbuylots;     // buy volume
__int64      covselllots;     // sell volume
double      covbuyprice;     // average buy price
double      covsellprice;    // average sell price
double      covprofit;      // coverage profit
};
//+------------------------------------------------------------------+
//| Currence exposure                                                |
//+------------------------------------------------------------------+
[Serializable]
public value class ExposureValue
{
public:
	String ^currency;     // currency
	double      clients;       // clients volume
	double      coverage;      // coverage volume
	ExposureValue(MetaQuotes::ExposureValue& Exp) {
		currency = Marshal::PtrToStringAnsi(IntPtr(Exp.currency));
		clients = Exp.clients;
		coverage = Exp.coverage;
	}

	ExposureValue(MetaQuotes::ExposureValue* Exp) {
		currency = Marshal::PtrToStringAnsi(IntPtr(Exp->currency));
		clients = Exp->clients;
		coverage = Exp->coverage;
	}


	void ToMT4(MetaQuotes::ExposureValue* Exp) {
		IntPtr temp_currency;
		char* temp;
		temp_currency = Marshal::StringToHGlobalAnsi(currency);
		temp = (char*)temp_currency.ToPointer();
		if (temp != NULL)
		strcpy(Exp->currency, (char *)(void *)temp_currency);
		Marshal::FreeHGlobal(temp_currency);
		Exp->clients = clients;
		Exp->coverage = coverage;
	}
};
//+------------------------------------------------------------------+
//| Symbol properties                                                |
//+------------------------------------------------------------------+
//---

[Serializable]
public value class SymbolProperties
{
public:
	String ^symbol;      // symbol
	COLORREF     color;  // symbol color
	int spread; // symbol spread
	int spread_balance;    // spread balance
	int stops_level;      // stops level
	int smoothing;       // smoothing
	int exemode; // execution mode
	SymbolProperties(MetaQuotes::SymbolProperties& Sym) {
		symbol = Marshal::PtrToStringAnsi(IntPtr(Sym.symbol));
		spread = Sym.spread;
		spread_balance = Sym.spread_balance;
		stops_level = Sym.stops_level;
		smoothing = Sym.smoothing;
		exemode = Sym.exemode;
	}

	SymbolProperties(MetaQuotes::SymbolProperties* Sym) {
		symbol = Marshal::PtrToStringAnsi(IntPtr(Sym->symbol));
		spread = Sym->spread;
		spread_balance = Sym->spread_balance;
		stops_level = Sym->stops_level;
		smoothing = Sym->smoothing;
		exemode = Sym->exemode;
	}

	void ToMT4(MetaQuotes::SymbolProperties* Sym) {
		IntPtr temp_symbol;
		char* temp;
		temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
		temp = (char*)temp_symbol.ToPointer();
		if (temp != NULL)
		strcpy(Sym->symbol, (char *)(void *)temp_symbol);
		Marshal::FreeHGlobal(temp_symbol);
		Sym->spread = spread;
		Sym->spread_balance = spread_balance;
		Sym->stops_level = stops_level;
		Sym->smoothing = smoothing;
		Sym->exemode = exemode;
	}
};

//+------------------------------------------------------------------+
//| Symbol tick                                                      |
//+------------------------------------------------------------------+
[Serializable]
public value class TickInfo
{
public:

TickInfo(MetaQuotes::TickInfo &ti)
{
	symbol = Marshal::PtrToStringAnsi(IntPtr(ti.symbol));
	ctm = ti.ctm;
	bid = ti.bid;
	ask = ti.ask;
}
TickInfo(MetaQuotes::TickInfo *ti)
{
	symbol = Marshal::PtrToStringAnsi(IntPtr(ti->symbol));
	ctm = ti->ctm;
	bid = ti->bid;
	ask = ti->ask;
}

void ToMT4(MetaQuotes::TickInfo* Tic) {
	IntPtr temp_symbol;
	char* temp;
	temp_symbol = Marshal::StringToHGlobalAnsi(symbol);
	temp = (char*)temp_symbol.ToPointer();
	if (temp != NULL)
	strcpy(Tic->symbol, (char *)(void *)temp_symbol);
	Marshal::FreeHGlobal(temp_symbol);
	Tic->ctm = ctm;
	Tic->bid = bid;
	Tic->ask = ask;
}

String ^symbol;       // symbol
__time32_t ctm;   // tick time
double      bid;   // bid
double      ask;   // ask
};
//+------------------------------------------------------------------+
//| Mail                                                             |
//+------------------------------------------------------------------+


[Serializable]
public value class MailBox
{

	    public:
	        MailBox(MetaQuotes::MailBox &mb)
	        {
	            time    = mb.time;
	           sender  = mb.sender;
			   from    = Marshal::PtrToStringAnsi(IntPtr(mb.from));
			   to      = mb.to;
			   subject = Marshal::PtrToStringAnsi(IntPtr(mb.subject));
			   readed = mb.readed == TRUE ? true : false;
			   body    = Marshal::PtrToStringAnsi(IntPtr(Helpers::Helper::GetBody(mb)));
			   bodylen = mb.bodylen;
			   build_min = mb.build_min;
			   build_max = mb.build_max;
	        }

			MailBox(MetaQuotes::MailBox *mb)
			{
				time = mb->time;
				sender = mb->sender;
				from = Marshal::PtrToStringAnsi(IntPtr(mb->from));
				to = mb->to;
				subject = Marshal::PtrToStringAnsi(IntPtr(mb->subject));
				readed = mb->readed == TRUE ? true : false;
				body = Marshal::PtrToStringAnsi(IntPtr(Helpers::Helper::GetBody(*mb)));
				bodylen = mb->bodylen;
				build_min = mb->build_min;
				build_max = mb->build_max;
			}

			void ToMT4(MetaQuotes::MailBox* Mai) {
				Mai->time = time;
				Mai->sender = sender;
				IntPtr temp_from;
				char* temp;
				temp_from = Marshal::StringToHGlobalAnsi(from);
				temp = (char*)temp_from.ToPointer();
				if (temp != NULL)
				strcpy(Mai->from, (char *)(void *)temp_from);
				Marshal::FreeHGlobal(temp_from);
				Mai->to = to;
				IntPtr temp_subject;
				temp_subject = Marshal::StringToHGlobalAnsi(subject);
				temp = (char*)temp_subject.ToPointer();
				if (temp != NULL)
				strcpy(Mai->subject, (char *)(void *)temp_subject);
				Marshal::FreeHGlobal(temp_subject);
				Mai->readed = readed;
				
				IntPtr temp_body;
				char* tempChar=new char[body->Length];
				temp_body = Marshal::StringToHGlobalAnsi(body);
				temp = (char*)temp_body.ToPointer();
				if (temp != NULL) {
					strcpy(tempChar, (char *)(void *)temp_body);
					Helpers::Helper::SetBody(Mai, tempChar);
				}
				Marshal::FreeHGlobal(temp_body);
				Mai->bodylen = bodylen;
				Mai->build_min = build_min;
				Mai->build_max = build_max;
			}

	__time32_t        time;                   // receive time
	int               sender;                 // mail sender (login)
	String            ^from;				  // mail sender (name)
	int               to;                     // mail recipient
	String            ^subject;				  // mail sumbect
	int               readed;                 // readed flag
	String            ^body;                   // pointer to mail body
	int               bodylen;                // mail body length
	short             build_min;              // minimum build
	short             build_max;              // maximum build
	
};

//+------------------------------------------------------------------+
//| News topic                                                       |
//+------------------------------------------------------------------+
[Serializable]
public value class NewsTopic
{
public:
	ULONG       key;   // news key
	__time32_t time;   // news time
	String ^ctm; // news source time ("yyyy/mm/dd hh:mm:ss")
	String ^topic;       // news topic
	String ^category;      // news category
	String ^keywords;     // news keywords
	String ^body;   // body (if present)
	int bodylen; // body length
	int readed;  // readed flag
	int priority; // news priority: 0-general, 1-high
	int langid;  // news LANGID

	NewsTopic(MetaQuotes::NewsTopic& New) {
		time = New.time;
		ctm = Marshal::PtrToStringAnsi(IntPtr(New.ctm));
		topic = Marshal::PtrToStringAnsi(IntPtr(New.topic));
		category = Marshal::PtrToStringAnsi(IntPtr(New.category));
		keywords = Marshal::PtrToStringAnsi(IntPtr(New.keywords));
		body = Marshal::PtrToStringAnsi(IntPtr(Helpers::Helper::GetNewsTopicBody(New)));
		bodylen = New.bodylen;
		readed = New.readed;
		priority = New.priority;
		langid = New.langid;
	}

	NewsTopic(MetaQuotes::NewsTopic* New) {
		time = New->time;
		ctm = Marshal::PtrToStringAnsi(IntPtr(New->ctm));
		topic = Marshal::PtrToStringAnsi(IntPtr(New->topic));
		category = Marshal::PtrToStringAnsi(IntPtr(New->category));
		keywords = Marshal::PtrToStringAnsi(IntPtr(New->keywords));
		body = Marshal::PtrToStringAnsi(IntPtr(Helpers::Helper::GetNewsTopicBody(*New)));
		bodylen = New->bodylen;
		readed = New->readed;
		priority = New->priority;
		langid = New->langid;
	}

	void ToMT4(MetaQuotes::NewsTopic* New) {
		New->key = key;
		New->time = time;
		IntPtr temp_ctm;
		char* temp;
		temp_ctm = Marshal::StringToHGlobalAnsi(ctm);
		temp = (char*)temp_ctm.ToPointer();
		if (temp != NULL)
		strcpy(New->ctm, (char *)(void *)temp_ctm);
		Marshal::FreeHGlobal(temp_ctm);
		IntPtr temp_topic;
		temp_topic = Marshal::StringToHGlobalAnsi(topic);
		temp = (char*)temp_topic.ToPointer();
		if (temp != NULL)
		strcpy(New->topic, (char *)(void *)temp_topic);
		Marshal::FreeHGlobal(temp_topic);
		IntPtr temp_category;
		temp_category = Marshal::StringToHGlobalAnsi(category);
		temp = (char*)temp_category.ToPointer();
		if (temp != NULL)
		strcpy(New->category, (char *)(void *)temp_category);
		Marshal::FreeHGlobal(temp_category);
		IntPtr temp_keywords;
		temp_keywords = Marshal::StringToHGlobalAnsi(keywords);
		temp = (char*)temp_keywords.ToPointer();
		if (temp != NULL)
		strcpy(New->keywords, (char *)(void *)temp_keywords);
		Marshal::FreeHGlobal(temp_keywords);


		IntPtr temp_body;
		char* tempChar = new char[body->Length];
		temp_body = Marshal::StringToHGlobalAnsi(body);
		temp = (char*)temp_body.ToPointer();
		if (temp != NULL) {
			strcpy(tempChar, (char *)(void *)temp_body);
			Helpers::Helper::SetNewsBody(New, tempChar);
		}
		Marshal::FreeHGlobal(temp_body);

		New->bodylen = bodylen;
		New->readed = readed;
		New->priority = priority;
		New->langid = langid;
	}

};
//+------------------------------------------------------------------+
//| Extended news structure                                          |
//+------------------------------------------------------------------+
[Serializable]
public value class NewsTopicNew
{

	NewsTopicNew(MetaQuotes::NewsTopicNew* New) {
		key = New->key;
		language = New->language;
		subject = Marshal::PtrToStringAnsi(IntPtr(New->subject));
		category = Marshal::PtrToStringAnsi(IntPtr(New->category));
		flags = New->flags;
		body = Marshal::PtrToStringAnsi(IntPtr(Helpers::Helper::GetTopicBody(New)));
		
		body_len = New->body_len;
		for (int i = 0; i < 32; i++) {
			languages_list[i] = languages_list[i];
		}
	}

	NewsTopicNew(MetaQuotes::NewsTopicNew& New) {
		key = New.key;
		language = New.language;
		subject = Marshal::PtrToStringAnsi(IntPtr(New.subject));
		category = Marshal::PtrToStringAnsi(IntPtr(New.category));
		flags = New.flags;
		body = Marshal::PtrToStringAnsi(IntPtr(Helpers::Helper::GetTopicBody(&New)));
		body_len = New.body_len;
		for (int i = 0; i < 32; i++) {
			languages_list[i] = languages_list[i];
		}
	}

	//--- constants
	enum class constants
	{
		MAX_NEWS_BODY_LEN = 15 * 1024 * 1024         // max. body len
	};
	//--- news topic flags
	enum class EnNewsFlags
	{
		FLAG_PRIORITY = 1,                   // priority flag
		FLAG_CALENDAR = 2,                   // calendar item flag
		FLAG_MIME = 4,                   // MIME news content
		FLAG_ALLOW_DEMO = 8                    // allow body for demo accounts
	};
	ULONG             key;                    // news key
	UINT              language;               // news language (WinAPI LANGID)
	String            ^subject;           // news subject
	String            ^category;          // news category
	UINT              flags;                  // EnNewsFlags
	String            ^body;                   // body
	UINT              body_len;               // body length
	List<UINT>^       languages_list;     // list of languages available for news
	INT64             datetime;               // news time

};

//+------------------------------------------------------------------+
//| Server journal record                                            |
//+------------------------------------------------------------------+
[Serializable]
public value class ServerLog
{
public:
	ServerLog(MetaQuotes::ServerLog &sl)
	{
		code = sl.code;
		time = Marshal::PtrToStringAnsi(IntPtr(sl.time));
		ip = Marshal::PtrToStringAnsi(IntPtr(sl.ip));
		message = Marshal::PtrToStringAnsi(IntPtr(sl.message));
	}

	ServerLog(MetaQuotes::ServerLog *sl)
	{
		code = sl->code;
		time = Marshal::PtrToStringAnsi(IntPtr(sl->time));
		ip = Marshal::PtrToStringAnsi(IntPtr(sl->ip));
		message = Marshal::PtrToStringAnsi(IntPtr(sl->message));
	}

	void ToMT4(MetaQuotes::ServerLog* Ser) {
		Ser->code = code;
		IntPtr temp_time;
		char* temp;
		temp_time = Marshal::StringToHGlobalAnsi(time);
		temp = (char*)temp_time.ToPointer();
		if (temp != NULL)
		strcpy(Ser->time, (char *)(void *)temp_time);
		Marshal::FreeHGlobal(temp_time);
		IntPtr temp_ip;
		temp_ip = Marshal::StringToHGlobalAnsi(ip);
		temp = (char*)temp_ip.ToPointer();
		if (temp != NULL)
		strcpy(Ser->ip, (char *)(void *)temp_ip);
		Marshal::FreeHGlobal(temp_ip);
		IntPtr temp_message;
		temp_message = Marshal::StringToHGlobalAnsi(message);
		temp = (char*)temp_message.ToPointer();
		if (temp != NULL)
		strcpy(Ser->message, (char *)(void *)temp_message);
		Marshal::FreeHGlobal(temp_message);
	}


	int               code;               // code
	String            ^time;              // time
	String            ^ip;                // ip
	String            ^message;           // message
};
//--- log record codes
public enum class EnErrLogTypes {
	CmdOK,  // OK
	CmdTrade, // trades only
	CmdLogin, // logins only
	CmdWarn, // warnings
	CmdErr,  // errors
	CmdAtt  // attention, important errors
};
//--- request logs type
public enum class EnLogType {
	LOG_TYPE_STANDARD = 0,  // all except logins
	LOG_TYPE_LOGINS = 1,  // logins only
	LOG_TYPE_TRADES = 2,  // trades only
	LOG_TYPE_ERRORS = 3,  // errors
	LOG_TYPE_FULL = 4,  // full log
						//---
						LOG_TYPE_UPDATER = 16,  // live update
						LOG_TYPE_SENDMAIL = 17,  // send mail
						LOG_TYPE_FAILOVER = 18  // failover
};
//--- request logs type
public enum class EnLogMode {
	LOG_MODE_ENABLED,    // manager api logs enabled
	LOG_MODE_DISABLED,   // manager api logs disabled
};
//+------------------------------------------------------------------+
//| Balance check                                                    |
//+------------------------------------------------------------------+

[Serializable]
public value class BalanceDiff
{
public:
	int login;
	double      diff;
	BalanceDiff(MetaQuotes::BalanceDiff& Bal) {
		login = Bal.login;
		diff = Bal.diff;
	}

	BalanceDiff(MetaQuotes::BalanceDiff* Bal) {
		login = Bal->login;
		diff = Bal->diff;
	}

	void ToMT4(MetaQuotes::BalanceDiff* Bal) {
		Bal->login = login;
		Bal->diff = diff;
	}
};


//+------------------------------------------------------------------+
//| Pumping notification codes                                       |
//+------------------------------------------------------------------+

public enum class PumpingMessages {
	PUMP_START_PUMPING = 0,      // pumping started
	PUMP_UPDATE_SYMBOLS,       // update symbols
	PUMP_UPDATE_GROUPS,        // update groups
	PUMP_UPDATE_USERS,         // update users
	PUMP_UPDATE_ONLINE,        // update online users
	PUMP_UPDATE_BIDASK,        // update bid/ask
	PUMP_UPDATE_NEWS,          // update news
	PUMP_UPDATE_NEWS_BODY,     // update news body
	PUMP_UPDATE_MAIL,          // update news
	PUMP_UPDATE_TRADES,        // update trades
	PUMP_UPDATE_REQUESTS,      // update trade requests
	PUMP_UPDATE_PLUGINS,       // update server plugins
	PUMP_UPDATE_ACTIVATION,    // new order for activation (sl/sp/stopout)
	PUMP_UPDATE_MARGINCALL,    // new margin calls
	PUMP_STOP_PUMPING,         // pumping stopped
	PUMP_PING,                 // ping
	PUMP_UPDATE_NEWS_NEW,      // update news in new format (NewsTopicNew structure)
};


//+------------------------------------------------------------------+
//| Dealing notification codes                                       |
//+------------------------------------------------------------------+
public enum class DealingNotificationCodes
{
	DEAL_START_DEALING = 0,      // dealing dispatcher started
	DEAL_REQUEST_NEW,          // new request
	DEAL_STOP_DEALING          // dealing dispatcher stopped
};

	
}
